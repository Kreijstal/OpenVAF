/*
 *  ******************************************************************************************
 *  Copyright (c) 2021 Pascal Kuthe. This file is part of the frontend project.
 *  It is subject to the license terms in the LICENSE file found in the top-level directory
 *  of this distribution and at  https://gitlab.com/DSPOM/OpenVAF/blob/master/LICENSE.
 *  No part of frontend, including this file, may be copied, modified, propagated, or
 *  distributed except according to the terms contained in the LICENSE file.
 *  *****************************************************************************************
 */

use crate::runtime::abi::{
    BranchCurrentsAndConductance, InternalData, ModelCard, NodePotentialOffsets,
};
use crate::{LoadFlags, OsdiModel, ReturnFlags};
use libloading::{Library, Symbol};
use std::ffi::c_void;
use std::path::Path;

pub mod abi;
//pub mod registry;
use std::ops::Deref;

/// Definitions of osdi model libary functions
/// For more detailed description read the OSDI standard!
pub mod model_lib_fn {
    pub const LOAD_FLAG_AC: u32 = 1;

    use std::ffi::c_void;
    pub type SetupModelCard = unsafe extern "C" fn(*mut u64);

    // fn model_init(modelcard, model_variables)
    pub type ModelInit = unsafe extern "C" fn(*mut u8, *mut u8) -> u64;

    // fn model_init(modelcard, model_variables,instance_variables)
    pub type InstanceInit = unsafe extern "C" fn(*mut u8, *mut u8, *mut u8) -> u64;

    /// ```
    ///    unsafe extern "C" fn lim_voltages(
    ///         new_voltages: *mut u64,
    ///         state_vec_0: *mut f64,
    ///         model_variables: *mut f64,
    ///         instace_variables: *mut f64
    ///     ){
    ///        // generated by OpenVAF
    ///     }
    /// ```
    pub type LimitVoltages = unsafe extern "C" fn(
        *mut u64, // new voltages
        *mut f64, // state_vec (zero. time step)
        *mut f64, // model variables
        *mut f64, //instace variables
    );

    /// ```
    /// #    use std::os::raw::{c_void};
    ///     unsafe extern "C" fn load(
    ///        ckt: *mut c_void, //
    ///        modelcard: *mut u8, //
    ///        instance_variables: *mut u8, //
    ///        mode_variables: *mut u8, // model variables
    ///        state_vector: *mut *mut u64, // state vectors
    ///        voltage_base_ptr: *mut f64, // voltages start
    ///        voltage_offsets: *mut usize,
    ///        currents: *mut f64,
    ///        flags: u32,
    ///     ){
    ///        // generated by OpenVAF
    ///     }
    /// ```
    pub type GlobalLoadFunction = unsafe extern "C" fn(
        *mut *mut f64, // External Jacobian ptrs
        *mut *mut u64, // state vectors
        *mut f64,      // voltages start
        *mut usize,    // voltage positions
        *mut f64,      // currents and conductances
        u32,
    ) -> u64;

    /// ```
    /// #    use std::os::raw::{c_void};
    ///     unsafe extern "C" fn load(
    ///        ckt: *mut c_void, //
    ///        modelcard: *mut u8, //
    ///        instance_variables: *mut u8, //
    ///        mode_variables: *mut u8, // model variables
    ///        state_vector: *mut *mut u64, // state vectors
    ///        voltage_base_ptr: *mut f64, // voltages start
    ///        voltage_offsets: *mut usize,
    ///        currents: *mut f64,
    ///        flags: u32,
    ///     ){
    ///        // generated by OpenVAF
    ///     }
    /// ```
    pub type InternalLoadFunction = unsafe extern "C" fn(
        *mut *mut f64, // Internal Jacobian ptrs
        *mut c_void,   // ckt (simulator context not used by osdi itself only by the interface)
        *mut u8,       // modelcard
        *mut u8,       // instance variables
        *mut u8,       // model variables
        *mut *mut u64, // state vectors
        *mut f64,      // voltages start
        *mut usize,    // voltage positions
        *mut f64,      // currents
        u32,
    ) -> u64;
}

pub struct OsdiModelRuntime {
    model_init: Symbol<'static, model_lib_fn::ModelInit>,
    instance_init: Symbol<'static, model_lib_fn::ModelInit>,
    global_load: Symbol<'static, model_lib_fn::GlobalLoadFunction>,
    internal_load: Symbol<'static, model_lib_fn::InternalLoadFunction>,
    setup_mc: Symbol<'static, model_lib_fn::SetupModelCard>,
}

impl OsdiModelRuntime {
    pub fn init(path: impl AsRef<Path>) -> Result<Self, libloading::Error> {
        let lib = Library::new(path.as_ref())?;
        let lib: &'static Library = Box::leak(Box::new(lib));
        let model_init = unsafe { lib.get(b"model_init\0")? };
        let instance_init = unsafe { lib.get(b"instance_init\0")? };
        let global_load = unsafe { lib.get(b"global_load\0")? };
        let internal_load = unsafe { lib.get(b"internal_load\0")? };
        let setup_mc = unsafe { lib.get(b"setup_modelcard\0")? };
        Ok(Self {
            global_load,
            internal_load,
            setup_mc,
            model_init,
            instance_init,
        })
    }
}

impl OsdiModel {
    /// # Safety
    /// `simulator_data`, `state_vec` and `voltage_base` must be valid for reads and properly aligned
    pub unsafe fn internal_load_routine(
        &self,
        matrix_patrs: *mut *mut f64,
        simulator_data: *mut c_void,
        modelcard: &ModelCard,
        model_variables: &InternalData,
        instance_variables: &mut InternalData,
        state_vec: *mut *mut u64,
        voltage_base: *mut f64,
        voltage_offsets: &NodePotentialOffsets,
        dst: &mut BranchCurrentsAndConductance,
        flags: LoadFlags,
    ) -> ReturnFlags {
        // This is save since it is a formal abi guarantee that modelcard and voltages are never written to
        // Furthermore we do no create or use different aliases till the end of the function
        let mc = modelcard.data() as *mut u8;
        let model_variables = model_variables.as_ptr() as *mut u8;

        let instance_variables = instance_variables.as_ptr_mut();
        let voltage_offsets = voltage_offsets.as_ptr() as *mut usize;
        let dst = dst.as_mut_ptr();

        let res = self.runtime.internal_load.deref()(
            matrix_patrs,
            simulator_data,
            mc,
            model_variables,
            instance_variables,
            state_vec,
            voltage_base,
            voltage_offsets,
            dst,
            flags.bits,
        );
        ReturnFlags::from_bits_unchecked(res)
    }
}
