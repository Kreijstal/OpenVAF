
//  * ******************************************************************************************
//  * Copyright (c) 2019 Pascal Kuthe. This file is part of the rust_adms project.
//  * It is subject to the license terms in the LICENSE file found in the top-level directory
//  *  of this distribution and at  https://gitlab.com/jamescoding/rust_adms/blob/master/LICENSE.
//  *  No part of rust_adms, including this file, may be copied, modified, propagated, or
//  *  distributed except according to the terms contained in the LICENSE file.
//  * *******************************************************************************************


WHITESPACE = _{ SEPARATOR|NEWLINE|CONTROL }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/"|"//"~(!NEWLINE~ANY)+ ~&NEWLINE}

//Operators
    OP_NOT=@{"!"}
    OP_AND = @{"&"}
    OP_NAND = @{"~&"}
    OP_NXOR = @{ "~^" |"^~"}
    OP_XOR = @{ "^"}
    OP_OR=@{"|"}
    OP_NOR = @ {"~|"}
    OP_BIT_NOT=@{"~"}

    OP_PLUS=@{"+"}
    OP_MINUS=@{"-"}
    OP_POT = @{"**"}
    OP_MUL=@{"*"}
    OP_DIV=@{"/"}
    OP_MOD=@{"%"}

    OP_LOGIC_LEFT=@{"<<"}
    OP_LOGIC_RIGHT=@{">>"}
    OP_ARITHMETIC_LEFT=@{"<<<"}
    OP_ARITHMETIC_RIGHT=@{">>>"}

    OP_LT = @{"<"}
    OP_LE = @{"<="}
    OP_GT = @{">"}
    OP_GE = @{">="}

    OP_EQ=@{"=="}
    OP_NE=@{"!="}

    OP_LOGIC_OR=@{"||"}
    OP_LOGIC_AND=@{"&&"}

    OP_COND={"?"~(EXPRESSION~":")?}

    OP_CASE_EQ=@{"==="}
    OP_CASE_NE=@{"!=="}

    OP_CONCAT=@{"{}"}
    OP_REPLICATION=@{"{{}}"}


//keywords
    TOK_MODULE = @{"macromodule"|"connectmodule"|"module"}
    TOK_ENDMODULE = @{"endmodule"}

    TOK_BRANCH = @{"branch"}
    TOK_PARAMETER  = @{"parameter"}
    TOK_LOCALPARAM =  @{"localparam" }
    TOK_DEFPARAM = @{"defparam"}
    TOK_ALIASPARAM = @{"aliasparam"}

    TOK_ANALOG = @{"analog"}
    TOK_INITIAL = @{"initial"}
    TOK_BEGIN = @{"begin"}
    TOK_END = @{"end"}

    TOK_IF = @{"if"}
    TOK_ELSE = @{"else"}
    TOK_ENDCASE = @{"endcase"}
    TOK_CASE = @{"case"~("z"|"x")?}
    TOK_DEFAULT = @{"endcase"}

    TOK_FOR = @{"for"}
    TOK_WHILE = @{"while"}

    TOK_IN= @{"input"}
    TOK_INOUT= @{"inout"}
    TOK_OUT= @{"output"}

    TOK_SIGNED= @{"signed"}
    TOK_VEKTORED = @{"vectored"}
    TOK_SCALARED = @{"scalared"}

    TOK_STRING=@{"string"}
    TOK_TIME= @{"time"}
    TOK_REALTIME= @{"realtime"}
    TOK_INTEGER= @{"integer"}
    TOK_REAL= @{"real"}

    TOK_REG=@{"reg"}
    TOK_WREAL= @{"wreal"}
    TOK_SUPPLY0=@{"supply0"}
    TOK_SUPPLY1=@{"supply1"}
    TOK_TRI=@{"tri"}
    TOK_TRIAND=@{"triand"}
    TOK_TRIOR=@{"trior"}
    TOK_TRI0=@{"tri0"}
    TOK_TRI1=@{"tri1"}
    TOK_WIRE=@{"wire"}
    TOK_UWIRE=@{"uwire"}
    TOK_WAND=@{"wand"}
    TOK_WOR=@{"wor"}
    TOK_TRIREG=@{"trireg"}
    TOK_GROUND=@{"ground"}
    TOK_EVENT=@{"event"}

    TOK_POTENTIAL = @{"potential"}
    TOK_FLOW = @{"flow"}


    TOK_TIME_DERIVATIVE = @{"ddt"}
    TOK_PARTIAL_DERIVATIVE = @{"ddx"}
    TOK_TIME_INTEGRAL = @{"idt"}
    TOK_TIME_INTEGRAL_MODULUS = @{"idtmod"}
    TOK_EXP = @{"exp"}
    TOK_SQRT = @{"sqrt"}
    TOK_POW = @{"pow"}
    TOK_WHITE_NOISE  = @{"white_noise"}
    TOK_FLICKER_NOISE  = @{"flicker_noise"}
    TOK_ABS = @{"abs"}
    TOK_FROM    = @{"from"   }
    TOK_EXCLUDE = @{"exclude"}
    TOK_INF = @{"inf"}

KEYWORD = @{TOK_MODULE|TOK_ENDMODULE|
    TOK_BRANCH|TOK_PARAMETER|TOK_LOCALPARAM|TOK_DEFPARAM|TOK_ALIASPARAM
    |TOK_ANALOG|TOK_INITIAL|TOK_BEGIN|TOK_END|
    TOK_CASE|TOK_IF|TOK_ELSE|TOK_FOR|TOK_WHILE|
    TOK_IN|TOK_OUT|TOK_INOUT|TOK_SIGNED|
    TOK_WREAL|TOK_SUPPLY0|TOK_SUPPLY1|TOK_TRI|TOK_TRIAND|TOK_TRIOR|TOK_TRI0|TOK_TRI1|TOK_WIRE|TOK_UWIRE|TOK_WAND|TOK_WOR|
    TOK_INTEGER|TOK_REG|TOK_REAL|TOK_REALTIME|TOK_TRIREG|TOK_GROUND|
    TOK_POTENTIAL|TOK_FLOW|
    TOK_TIME_DERIVATIVE|TOK_PARTIAL_DERIVATIVE|TOK_TIME_INTEGRAL|TOK_TIME_INTEGRAL_MODULUS}
STANDARD_FUNCTIONS = @{TOK_EXP|TOK_TIME_DERIVATIVE|TOK_PARTIAL_DERIVATIVE|TOK_TIME_INTEGRAL|TOK_TIME_INTEGRAL_MODULUS|TOK_SQRT|TOK_POW|TOK_WHITE_NOISE|TOK_FLICKER_NOISE|TOK_ABS}
IDENTIFIER=@{"\\" ~ (NUMBER|LETTER_NUMBER|SYMBOL|PUNCTUATION)+ ~WHITE_SPACE|SIMPLE_IDENTIFIER}
    SIMPLE_IDENTIFIER=@{KEYWORD~(LETTER|NUMBER|"_"|"$")+|!KEYWORD ~ (LETTER|"_") ~ (LETTER|NUMBER|"_"|"$")*}
    HIERARCHICAL_ID={IDENTIFIER~("."~IDENTIFIER)*}
    IDENTIFIER_LIST = {IDENTIFIER~(","~IDENTIFIER)*}
    VARIABLE_IDENTIFIER_LIST = {IDENTIFIER~("="~CONSTANT_EXPRESSION)?~(","~IDENTIFIER~("="~CONSTANT_EXPRESSION)?)*}

    SYSTEM_IDENTIFER = @{"$"~(LETTER|NUMBER|"$"|"_")+}
    SYSTEM_CALL = {SYSTEM_IDENTIFER~("("~EXPRESSION?~(","~EXPRESSION)*~")")?}
    //TODO merge with branch probe
   FUNCTION_CALL = {(STANDARD_FUNCTIONS/*|HIERARCHICAL_ID*/)~"("~EXPRESSION?~(","~EXPRESSION)*~")"}

UNSIGNED_NUMBER = @{ASCII_DIGIT~(IGNORE_UNDERSCORE|ASCII_DIGIT)*}
REAL_NUMBER = ${UNSIGNED_NUMBER~(
    ("."~UNSIGNED_NUMBER)?~(SCALE_FACTOR|EXP~SIGN?~UNSIGNED_NUMBER)
    |"."~UNSIGNED_NUMBER)}

    EXP = @{"e"|"E"}
    SCALE_FACTOR = @{"T"|"G"|"M"|"K"|"k"|"m"|"u"|"p"|"f"|"a"}
    SIGN = @{OP_PLUS|OP_MINUS}
    IGNORE_UNDERSCORE = _{"_"}

STRING = ${"\""~STRING_LITERAL~"\""}
STRING_LITERAL = @{(LETTER|NUMBER|SPACE_SEPARATOR|"\\"~("t"|"n"|"\""|NUMBER{3}|"\\")|(!("\\"|"\"")~(SYMBOL|PUNCTUATION)))*}

ATTRIBUTE = {"(*" ~ ATTRIBUTE_SPEC ~ (","~ATTRIBUTE_SPEC)*~"*)"}
ATTRIBUTE_SPEC = {IDENTIFIER~  ("="~CONSTANT_EXPRESSION)? }

NET_TYPE = {TOK_SUPPLY0|TOK_SUPPLY1|TOK_TRI|TOK_TRIAND|TOK_TRIOR
    |TOK_TRI0|TOK_TRI1|TOK_WIRE|TOK_UWIRE|TOK_WAND|TOK_WOR}

VERILOG_AMS = {SOI ~ (TOP_ITEM)* ~ EOI}

TOP_ITEM = {ATTRIBUTE*~MODULE}
MODULE = {TOK_MODULE ~ IDENTIFIER~ PARAMETER_DECLERATION_LIST? ~(
"("~PORT_LIST~")"~";" ~ (MODULE_ITEM|ATTRIBUTE*~PORT_DECLARATION~";")*
|("("~PORT_DECLARATION_LIST~")")?~";" ~ MODULE_ITEM*
)~ TOK_ENDMODULE}
    //TODO GENERATE,SPECIFY,SPECPARAM;ALIASPARAM
    MODULE_ITEM = {MODULE_OR_GENERATE_ITEM|ATTRIBUTE* ~ PARAMETER_DECLERATION~";"}

MODULE_OR_GENERATE_ITEM = {
    ATTRIBUTE* ~ (ANALOG|VARIABLE_DECELERATION|BRANCH_DECELERATION)
}

BEHAVIORAL_STMT = {
    ATTRIBUTE* ~ (TIMING_CONTROL|CONDITONAL_STATEMENT|CASE_STATEMENT|SEQ_BLOCK|CONTRIBUTE_STMT|INDIRECT_CONTRIBUTE_STMT|VARIABLE_ASSIGNMENT~";"|";")
}
    //general
    SEQ_BLOCK = {TOK_BEGIN
        ~(":"~IDENTIFIER~(ATTRIBUTE* ~ (PARAMETER_DECLERATION~";"|VARIABLE_DECELERATION))*  )?
        ~ BEHAVIORAL_STMT+ ~ TOK_END
    }
    //TODO DIMESION/ARRAYINIT
    //Type checking will be done during schematic
    VARIABLE_DECELERATION = {
        ((NET_TYPE|TOK_TRIREG|TOK_WREAL|TOK_GROUND|TOK_REG)~(
            IDENTIFIER~((CHARGE_STRENGTH|DRIVE_STRENGTH|TOK_SIGNED)+|&IDENTIFIER)
            |(CHARGE_STRENGTH|DRIVE_STRENGTH)?~TOK_SIGNED?
        )~ (IDENTIFIER_LIST|VARIABLE_IDENTIFIER_LIST)
        | (TOK_REAL|TOK_INTEGER|TOK_TIME|TOK_REALTIME|TOK_EVENT) ~VARIABLE_IDENTIFIER_LIST
        | IDENTIFIER ~RANGE_DECL?~ VARIABLE_IDENTIFIER_LIST)~";"
    }


PARAMETER_DECLERATION = {(TOK_PARAMETER|TOK_LOCALPARAM)
~(TOK_INTEGER|TOK_REAL|TOK_REALTIME|TOK_TIME|TOK_STRING|TOK_SIGNED?~RANGE_DECL?)
~PARAMETER_ASSIGNMET~(","~PARAMETER_ASSIGNMET)*}
    PARAMETER_ASSIGNMET = {IDENTIFIER~"="~MINTYPEMAX_EXPRESSION~VALUE_RANGE*}
    PARAMETER_DECLERATION_LIST={"#(" ~ PARAMETER_DECLERATION ~ ("," ~ PARAMETER_DECLERATION)* ~ ")"}
    DRIVE_STRENGTH = {"TODO"}
    CHARGE_STRENGTH = {"TODO"}


PORT_DECLARATION =
    {(TOK_INOUT|TOK_IN|TOK_OUT)
        ~(IDENTIFIER ~ (NET_TYPE|TOK_WREAL|TOK_SIGNED|RANGE_DECL)+ |IDENTIFIER ~ &IDENTIFIER|(NET_TYPE|TOK_WREAL|TOK_SIGNED|RANGE_DECL)*)
        ~IDENTIFIER_LIST
    | TOK_OUT
        ~((IDENTIFIER)?~ TOK_REG ~ TOK_SIGNED? ~  RANGE_DECL?
        |TOK_INTEGER~TOK_TIME)
        ~ VARIABLE_IDENTIFIER_LIST}
    PORT_DECLARATION_LIST = {ATTRIBUTE*~PORT_DECLARATION~(","~ATTRIBUTE*~PORT_DECLARATION)*
}

PORT = {"."~IDENTIFIER~"("~PORT_EXPRESSION?~")"|PORT_EXPRESSION?}
    PORT_EXPRESSION = {PORT_REFRENCE|"{"~PORT_REFRENCE~(","~PORT_REFRENCE)*~"}"}
    PORT_REFRENCE = {IDENTIFIER~CONSTANT_RANGE?}
    PORT_LIST={PORT~(","~PORT)*}

    VARIABLE_LVALUE= {(HIERARCHICAL_ID|"{"~HIERARCHICAL_ID~(","~HIERARCHICAL_ID)*~"}") }
    VARIABLE_ASSIGNMENT = {VARIABLE_LVALUE~"="~EXPRESSION}




    CONDITONAL_STATEMENT = {
        TOK_IF ~ "("~EXPRESSION~")"~BEHAVIORAL_STMT
        ~ (TOK_ELSE ~ TOK_IF ~ "("~EXPRESSION~")"~BEHAVIORAL_STMT)*
        ~(TOK_ELSE ~ BEHAVIORAL_STMT)?
    }
    CASE_STATEMENT = {
        TOK_CASE ~ "("~EXPRESSION~")"~CASE_ITEM+ ~ TOK_ENDCASE
    }
        CASE_ITEM = {
            (TOK_DEFAULT ~ ":"?|EXPRESSION~(","~EXPRESSION)*~":")~BEHAVIORAL_STMT
        }

    TIMING_CONTROL = {
            (DELAY_CONTROL | EVENT_CONTROL) ~ BEHAVIORAL_STMT
        }
            EVENT_CONTROL = {
                "@"~(HIERARCHICAL_ID|"*"|"("~("*"|EVENT_EXPRESSION)~")")
            }
    //analog
    ANALOG = { TOK_ANALOG ~ (TOK_INITIAL ~ BEHAVIORAL_STMT|BEHAVIORAL_STMT)}

    CONTRIBUTE_STMT = {
        BRANCH_LVALUE~"<+"~EXPRESSION~";"
    }
        BRANCH_LVALUE = {
        NATURE_ACCESS ~ BRANCH_IDENTIFIER
        }
        BRANCH_IDENTIFIER = {
            "("~ HIERARCHICAL_ID ~ SINGEL_RANGE? ~ (","~ HIERARCHICAL_ID ~ SINGEL_RANGE?)?~")"
        }
        PORT_BRANCH_IDENTIFIER = {
            "(<" ~ HIERARCHICAL_ID ~ SINGEL_RANGE? ~">)"
        }
        NATURE_ACCESS = {
            TOK_POTENTIAL|TOK_FLOW|IDENTIFIER
        }

    INDIRECT_CONTRIBUTE_STMT = {
           BRANCH_LVALUE ~ ":" ~ (INDIREKT_EXPRESSION) ~ "==" ~ EXPRESSION ~ ";"
       }
        INDIREKT_EXPRESSION = {
            BRANCH_RVALUE
            | TOK_TIME_DERIVATIVE ~ "(" ~BRANCH_RVALUE ~ (","~CONSTANT_EXPRESSION)?~")"
            | TOK_TIME_INTEGRAL_MODULUS ~ "(" ~BRANCH_RVALUE ~ (","~EXPRESSION){0,4}~")"
            | TOK_TIME_INTEGRAL ~ "(" ~BRANCH_RVALUE ~ (","~EXPRESSION){0,3}~")"
        }

        BRANCH_RVALUE = {
            NATURE_ACCESS ~ (PORT_BRANCH_IDENTIFIER|BRANCH_IDENTIFIER)
        }
    BRANCH_DECELERATION = {
        TOK_BRANCH~(BRANCH_IDENTIFIER|PORT_BRANCH_IDENTIFIER) ~IDENTIFIER_LIST~";"
    }



    //digital
    DELAY_CONTROL = {"#"~(
        (REAL_NUMBER|UNSIGNED_NUMBER|IDENTIFIER)
        |"("~MINTYPEMAX_EXPRESSION~")"
    )}





RANGE_DECL = {"["~ CONSTANT_EXPRESSION ~ ":"~CONSTANT_EXPRESSION ~"]"}
RANGE = { "["~(
    EXPRESSION
    |EXPRESSION ~ RANGE_SEPERATOR ~EXPRESSION
    )~"]"
}
VALUE_RANGE = {(TOK_FROM|TOK_EXCLUDE)~(("("|"[")~VALUE_EXPRESSION~":"~VALUE_EXPRESSION~("]"|")")|"'{"~STRING~(","~STRING)*~"}")|TOK_EXCLUDE~CONSTANT_EXPRESSION}
VALUE_EXPRESSION = {OP_MINUS?~TOK_INF|CONSTANT_EXPRESSION}

CONSTANT_RANGE = { "["~(
        CONSTANT_EXPRESSION
        |CONSTANT_EXPRESSION ~ RANGE_SEPERATOR ~CONSTANT_EXPRESSION
        )~"]"}

    RANGE_SEPERATOR = _{
        ":"|"+:"|"-:"
    }
SINGEL_RANGE = {"["~CONSTANT_EXPRESSION~"]"}





CONSTANT_EXPRESSION = {EXPRESSION}

EXPRESSION = {
    (   // THESE ARE TREATED AS PRIMARIES DURING OPERATOR PRECEDENCE PARSING
        ("("~EXPRESSION~")"|PRIMARY|UNARY_OPERATOR)
        ~(  /*
            BINARY OPERATORS
            OPERATOR PRECEDENCE IS PARSED DURING AST GENERATION
            PRECEDENCE HERE ENSURES THAT OPERATORS ARE FULLY PARSED: for example ~^instead of just ~
            */
            OP_CASE_EQ|OP_CASE_NE|
            OP_EQ|OP_NE|
            OP_LE|OP_LT|OP_GE|OP_GT|
            OP_LOGIC_AND|OP_LOGIC_OR|

            OP_PLUS|OP_MINUS|
            OP_POT|OP_MUL|OP_DIV|OP_MOD|

            OP_ARITHMETIC_RIGHT|OP_ARITHMETIC_LEFT|
            OP_LOGIC_LEFT|OP_LOGIC_RIGHT|

            OP_NAND|OP_NXOR|OP_NOR|
            OP_OR|OP_AND|OP_BIT_NOT|OP_XOR|

            OP_COND|

            OP_CONCAT|OP_REPLICATION)
        )*~("("~EXPRESSION~")"|PRIMARY|UNARY_OPERATOR)
}

UNARY_OPERATOR ={(OP_NAND|OP_NXOR|OP_NOR|
                    OP_OR|OP_AND|OP_XOR|
                    OP_BIT_NOT|OP_NOT|
                    OP_PLUS|OP_MINUS)
                ~(PRIMARY|"("~EXPRESSION~")")}

    PRIMARY = {SYSTEM_CALL|FUNCTION_CALL|STRING|REAL_NUMBER|UNSIGNED_NUMBER|BRANCH_RVALUE|HIERARCHICAL_ID}

MINTYPEMAX_EXPRESSION = {EXPRESSION|EXPRESSION~":"~EXPRESSION~":"~EXPRESSION}
EVENT_EXPRESSION = {
EXPRESSION| "TODO" ~ EXPRESSION
}






