
//  * ******************************************************************************************
//  * Copyright (c) 2019 Pascal Kuthe. This file is part of the rust_adms project.
//  * It is subject to the license terms in the LICENSE file found in the top-level directory
//  *  of this distribution and at  https://gitlab.com/jamescoding/rust_adms/blob/master/LICENSE.
//  *  No part of rust_adms, including this file, may be copied, modified, propagated, or
//  *  distributed except according to the terms contained in the LICENSE file.
//  * *******************************************************************************************

//  PREPROCESSOR
TOK_COMPILER_DIRECTIVE_START = _{"`"}
TOK_IFDEF=@{"ifdef "}
TOK_IFNDEF=@{TOK_COMPILER_DIRECTIVE_START~"ifndef "}
TOK_ELSIF=@{TOK_COMPILER_DIRECTIVE_START~"elsif "}
TOK_ENDIF=@{TOK_COMPILER_DIRECTIVE_START~"endif"}
TOK_ELSEDEF=@{TOK_COMPILER_DIRECTIVE_START~TOK_ELSE}
TOK_DEFINE=@{"define "}

USED_MACROS={
TOK_ELSE|"endif"|"elsif"
}

PREPROCESSOR = ${SOI~BODY~EOI}
BODY = ${COMPILER_DIRECTIVE_OR_CODE*}
COMPILER_DIRECTIVE_OR_CODE = ${TOK_COMPILER_DIRECTIVE_START~COMPILER_DIRECTIVE|CODE}

CODE = @{(LETTER|NUMBER|NEWLINE|SPACE_SEPARATOR|PUNCTUATION|!TOK_COMPILER_DIRECTIVE_START~SYMBOL)+}

//TODO OTHER PREDEFINED COMPILER DIRECTIVES
COMPILER_DIRECTIVE={MACRO_DEFINITION|MACRO_CONDITION|MACRO_REFERENCE}

//TODO remove stack doesnt work for aribitrary order
MACRO_DEFINITION = {TOK_DEFINE~IDENTIFIER~("("~IDENTIFIER_LIST~")")?~MACRO_DEFINITION_BODY?~DROP*}
    MACRO_DEFINITION_BODY = ${MACRO_DEFINTION_LINE~(NEWLINE~"\\"~MACRO_DEFINTION_LINE)*}
    MACRO_DEFINTION_LINE =${(TOK_COMPILER_DIRECTIVE_START~COMPILER_DIRECTIVE|SIMPLE_IDENTIFIER|MACRO_CODE)*}
    MACRO_CODE = ${(NUMBER|!"_"~PUNCTUATION|!TOK_COMPILER_DIRECTIVE_START~SYMBOL|SPACE_SEPARATOR)+}

MACRO_REFERENCE=${!USED_MACROS~IDENTIFIER~("("~MACRO_ARGUMENT_LIST~")")?}
    MACRO_ARGUMENT_LIST={EXPRESSION~(","~EXPRESSION)*}
MACRO_CONDITION=${(TOK_IFDEF|TOK_IFNDEF)~WHITE_SPACE*~IDENTIFIER~BODY
    ~(TOK_ELSIF~WHITE_SPACE*~IDENTIFIER~BODY)*
    ~(TOK_ELSEDEF~BODY)?
    ~TOK_ENDIF}



WHITESPACE = _{ SPACE_SEPARATOR|NEWLINE }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

//Operators
    OP_NOT=@{"!"}
    OP_AND = @{"&"}
    OP_NAND = @{"~&"}
    OP_NXOR = @{ "~^" |"^~"}
    OP_XOR = @{ "^"}
    OP_OR=@{"|"}
    OP_NOR = @ {"~|"}
    OP_BIT_NOT=@{"~"}

    OP_PLUS=@{"+"}
    OP_MINUS=@{"-"}
    OP_POT = @{"**"}
    OP_MUL=@{"*"}
    OP_DIV=@{"/"}
    OP_MOD=@{"%"}

    OP_LOGIC_LEFT=@{"<<"}
    OP_LOGIC_RIGHT=@{">>"}
    OP_ARITHMETIC_LEFT=@{"<<<"}
    OP_ARITHMETIC_RIGHT=@{">>>"}

    OP_LT = @{"<"}
    OP_LE = @{"<="}
    OP_GT = @{">"}
    OP_GE = @{">="}

    OP_EQ=@{"=="}
    OP_NE=@{"!="}

    OP_LOGIC_OR=@{"||"}
    OP_LOGIC_AND=@{"&&"}

    OP_COND={"?"~(EXPRESSION~":")?}

    OP_CASE_EQ=@{"==="}
    OP_CASE_NE=@{"!=="}

    OP_CONCAT=@{"{}"}
    OP_REPLICATION=@{"{{}}"}


//keywords
    TOK_MODULE = @{"macromodule"|"connectmodule"|"module"}
    TOK_ENDMODULE = @{"endmodule"}

    TOK_BRANCH = @{"branhc"}
    TOK_PARAMETER  = @{"parameter"}
    TOK_LOCALPARAM =  @{"localparam" }
    TOK_DEFPARAM = @{"defparam"}
    TOK_ALIASPARAM = @{"aliasparam"}

    TOK_ANALOG = @{"analog"}
    TOK_INITIAL = @{"initial"}
    TOK_BEGIN = @{"begin"}
    TOK_END = @{"end"}

    TOK_IF = @{"if"}
    TOK_ELSE = @{"else"}
    TOK_ENDCASE = @{"endcase"}
    TOK_CASE = @{"case"~("z"|"x")?}
    TOK_DEFAULT = @{"endcase"}

    TOK_FOR = @{"for"}
    TOK_WHILE = @{"while"}

    TOK_IN= @{"input"}
    TOK_INOUT= @{"inout"}
    TOK_OUT= @{"output"}

    TOK_SIGNED= @{"signed"}
    TOK_VEKTORED = @{"vectored"}
    TOK_SCALARED = @{"scalared"}


    TOK_TIME= @{"time"}
    TOK_REALTIME= @{"realtime"}
    TOK_INTEGER= @{"integer"}
    TOK_REAL= @{"real"}

    TOK_REG=@{"reg"}
    TOK_WREAL= @{"wreal"}
    TOK_SUPPLY0=@{"supply0"}
    TOK_SUPPLY1=@{"supply1"}
    TOK_TRI=@{"tri"}
    TOK_TRIAND=@{"triand"}
    TOK_TRIOR=@{"trior"}
    TOK_TRI0=@{"tri0"}
    TOK_TRI1=@{"tri1"}
    TOK_WIRE=@{"wire"}
    TOK_UWIRE=@{"uwire"}
    TOK_WAND=@{"wand"}
    TOK_WOR=@{"wor"}
    TOK_TRIREG=@{"trireg"}
    TOK_GROUND=@{"ground"}
    TOK_EVENT=@{"event"}

    TOK_POTENTIAL = @{"potential"}
    TOK_FLOW = @{"flow"}


    TOK_TIME_DERIVATIVE = @{"ddt"}
    TOK_PARTIAL_DERIVATIVE = @{"ddx"}
    TOK_TIME_INTEGRAL = @{"idt"}
    TOK_TIME_INTEGRAL_MODULUS = @{"idtmod"}


KEYWORD = @{TOK_MODULE|TOK_ENDMODULE|
    TOK_BRANCH|TOK_PARAMETER|TOK_LOCALPARAM|TOK_DEFPARAM|TOK_ALIASPARAM
    |TOK_ANALOG|TOK_INITIAL|TOK_BEGIN|TOK_END|
    TOK_CASE|TOK_IF|TOK_ELSE|TOK_FOR|TOK_WHILE|
    TOK_IN|TOK_OUT|TOK_INOUT|TOK_SIGNED|
    TOK_WREAL|TOK_SUPPLY0|TOK_SUPPLY1|TOK_TRI|TOK_TRIAND|TOK_TRIOR|TOK_TRI0|TOK_TRI1|TOK_WIRE|TOK_UWIRE|TOK_WAND|TOK_WOR|
    TOK_INTEGER|TOK_REG|TOK_REAL|TOK_REALTIME|TOK_TRIREG|TOK_GROUND|
    TOK_POTENTIAL|TOK_FLOW|
    TOK_TIME_DERIVATIVE|TOK_PARTIAL_DERIVATIVE|TOK_TIME_INTEGRAL|TOK_TIME_INTEGRAL_MODULUS}

IDENTIFIER=@{"\\" ~ (NUMBER|LETTER_NUMBER|SYMBOL|PUNCTUATION)+ ~WHITE_SPACE|SIMPLE_IDENTIFIER}
    SIMPLE_IDENTIFIER=@{KEYWORD~(LETTER|NUMBER|"_"|"$")+|!KEYWORD ~ (LETTER|"_") ~ (LETTER|NUMBER|"_"|"$")*}
    HIERARCHICAL_ID={IDENTIFIER~(":"~IDENTIFIER)*}
    IDENTIFIER_LIST = {IDENTIFIER~(","~IDENTIFIER)*}
    VARIABLE_IDENTIFIER_LIST = {IDENTIFIER~("="~CONSTANT_EXPRESSION)?~(","~IDENTIFIER~("="~CONSTANT_EXPRESSION)?)*}


UNSIGNED_NUMBER = @{ASCII_DIGIT~(IGNORE_UNDERSCORE|ASCII_DIGIT)*}
REAL_NUMBER = ${UNSIGNED_NUMBER~(
    ("."~UNSIGNED_NUMBER)?~(SCALE_FACTOR|EXP~SIGN?~UNSIGNED_NUMBER)
    |"."~UNSIGNED_NUMBER)}

    EXP = @{"e"|"E"}
    SCALE_FACTOR = @{"T"|"G"|"M"|"K"|"k"|"m"|"u"|"p"|"f"|"a"}
    SIGN = @{OP_PLUS|OP_MINUS}
    IGNORE_UNDERSCORE = _{"_"}


ATTRIBUTE = {"(*" ~ ATTRIBUTE_SPEC ~ (","~ATTRIBUTE_SPEC)*~"*)"}
ATTRIBUTE_SPEC = {IDENTIFIER~  ("="~CONSTANT_EXPRESSION)? }

NET_TYPE = {TOK_SUPPLY0|TOK_SUPPLY1|TOK_TRI|TOK_TRIAND|TOK_TRIOR
    |TOK_TRI0|TOK_TRI1|TOK_WIRE|TOK_UWIRE|TOK_WAND|TOK_WOR}

VERILOG_AMS = {SOI ~ (MODULE)* ~ EOI}


MODULE = {ATTRIBUTE* ~ TOK_MODULE ~ IDENTIFIER~ PARAMETER_DECLERATION_LIST? ~(
"("~PORT_LIST~")"~";" ~ (MODULE_ITEM|PORT_DECLARATION~";")*
|("("~PORT_DECLARATION_LIST~")")?~";" ~ MODULE_ITEM*
)~ TOK_ENDMODULE}
    //TODO GENERATE,SPECIFY,SPECPARAM;ALIASPARAM
    MODULE_ITEM = {MODULE_OR_GENERATE_ITEM|ATTRIBUTE* ~ PARAMETER_DECLERATION~";"}

MODULE_OR_GENERATE_ITEM = {
    ATTRIBUTE* ~ (ANALOG|VARIABEL_DECLERATION)
}

BEHAVIORAL_STMT = {
    TIMING_CONTROL|CONDITONAL_STATEMENT|CASE_STATEMENT|SEQ_BLOCK|CONTRIBUTE_STMT|INDIREKT_CONTRIBUTE_STMT|CONSTANT_EXPRESSION
}
    //general
    SEQ_BLOCK = {TOK_BEGIN
        ~(":"~IDENTIFIER~(ATTRIBUTE* ~ (PARAMETER_DECLERATION~";"|INTEGER_DECLERATION|REAL_DECLERATION))*  )?
        ~ BEHAVIORAL_STMT+ ~ TOK_END
    }
    //TODO DIMESION/ARRAYINIT
    //Type checking will be done during schematic
    VARIABEL_DECLERATION = {
        (NET_TYPE|TOK_TRIREG|TOK_WREAL|TOK_GROUND|TOK_REG)~(
            IDENTIFIER~((CHARGE_STRENGTH|DRIVE_STRENGTH|TOK_SIGNED)+|&IDENTIFIER)
            |(CHARGE_STRENGTH|DRIVE_STRENGTH)?~TOK_SIGNED?
        )~ (IDENTIFIER_LIST|VARIABLE_IDENTIFIER_LIST)
        | (TOK_REAL|TOK_INTEGER|TOK_TIME|TOK_REALTIME|TOK_EVENT) ~VARIABLE_IDENTIFIER_LIST
    }
    DRIVE_STRENGTH = {"TODO"}
    CHARGE_STRENGTH = {"TODO"}

    CONDITONAL_STATEMENT = {
        TOK_IF ~ "("~EXPRESSION~")"~BEHAVIORAL_STMT
        ~ (TOK_ELSE ~ TOK_IF ~ "("~EXPRESSION~")"~BEHAVIORAL_STMT)*
        ~(TOK_ELSE ~ BEHAVIORAL_STMT)?
    }
    CASE_STATEMENT = {
        TOK_CASE ~ "("~EXPRESSION~")"~CASE_ITEM+ ~ TOK_ENDCASE
    }
        CASE_ITEM = {
            (TOK_DEFAULT ~ ":"?|EXPRESSION~(","~EXPRESSION)*~":")~BEHAVIORAL_STMT
        }

    TIMING_CONTROL = {
            (DELAY_CONTROL | EVENT_CONTROL) ~ BEHAVIORAL_STMT
        }
            EVENT_CONTROL = {
                "@"~(HIERARCHICAL_ID|"*"|"("~("*"|EVENT_EXPRESSION)~")")
            }
    //analog
    ANALOG = { TOK_ANALOG ~ (TOK_INITIAL ~ BEHAVIORAL_STMT|BEHAVIORAL_STMT)}

    CONTRIBUTE_STMT = {
        BRANCH_LVALUE~"<+"~EXPRESSION~";"
    }
        BRANCH_LVALUE = {
        NATURE_ACCESS ~ BRANCH_IDENTIFIER
        }
        BRANCH_IDENTIFIER = {
            "("~ HIERARCHICAL_ID ~ SINGEL_RANGE? ~ (","~ HIERARCHICAL_ID ~ SINGEL_RANGE?)?~")"
        }
        PORT_BRANCH_IDENTIFIER = {
            "(<" ~ HIERARCHICAL_ID ~ SINGEL_RANGE? ~">)"
        }
        NATURE_ACCESS = {
            TOK_POTENTIAL|TOK_FLOW|IDENTIFIER
        }

    INDIREKT_CONTRIBUTE_STMT = {
           BRANCH_LVALUE ~ ":" ~ (INDIREKT_EXPRESSION) ~ "==" ~ EXPRESSION ~ ";"
       }
        INDIREKT_EXPRESSION = {
            BRANCH_RVALUE
            | TOK_TIME_DERIVATIVE ~ "(" ~BRANCH_RVALUE ~ (","~CONSTANT_EXPRESSION)?~")"
            | TOK_TIME_INTEGRAL_MODULUS ~ "(" ~BRANCH_RVALUE ~ (","~EXPRESSION){0,4}~")"
            | TOK_TIME_INTEGRAL ~ "(" ~BRANCH_RVALUE ~ (","~EXPRESSION){0,3}~")"
        }

        BRANCH_RVALUE = {
            NATURE_ACCESS ~ (PORT_BRANCH_IDENTIFIER|BRANCH_IDENTIFIER)
        }
    BRANCH_DECLERATION = {
        TOK_BRANCH~(BRANCH_IDENTIFIER|PORT_BRANCH_IDENTIFIER) ~IDENTIFIER~(","~IDENTIFIER)*~";"
    }



    //digital
    DELAY_CONTROL = {"#"~(
        (REAL_NUMBER|UNSIGNED_NUMBER|IDENTIFIER)
        |"("~MINTYPEMAX_EXPRESSION~")"
    )}




PORT_DECLARATION =
    {ATTRIBUTE* ~ (TOK_INOUT|TOK_IN|TOK_OUT)
        ~(IDENTIFIER ~ (NET_TYPE|TOK_WREAL|TOK_SIGNED|RANGE_DECL)+ |IDENTIFIER ~ &IDENTIFIER|(NET_TYPE|TOK_WREAL|TOK_SIGNED|RANGE_DECL)*)
        ~IDENTIFIER_LIST
    | ATTRIBUTE* ~ TOK_OUT
        ~((IDENTIFIER)?~ TOK_REG ~ TOK_SIGNED? ~  RANGE_DECL?
        |TOK_INTEGER~TOK_TIME)
        ~ VARIABLE_IDENTIFIER_LIST}
    PORT_DECLARATION_LIST = {PORT_DECLARATION~(","~PORT_DECLARATION)*
}

PORT = {"."~IDENTIFIER~"("~PORT_EXPRESSION?~")"|IDENTIFIER~CONSTANT_RANGE?}
    PORT_EXPRESSION = {PORT_REFRENCE|"{"~PORT_REFRENCE~(","~PORT_REFRENCE)*~"}"}
    PORT_REFRENCE = {IDENTIFIER~CONSTANT_RANGE?}
    PORT_LIST={PORT~(","~PORT)*}



RANGE_DECL = {"["~ CONSTANT_EXPRESSION ~ ":"~CONSTANT_EXPRESSION ~"]"}
RANGE = { "["~(
    EXPRESSION
    |EXPRESSION ~ RANGE_SEPERATOR ~EXPRESSION
    )~"]"
}
    CONSTANT_RANGE = { "["~(
        CONSTANT_EXPRESSION
        |CONSTANT_EXPRESSION ~ RANGE_SEPERATOR ~CONSTANT_EXPRESSION
        )~"]"
    }
    RANGE_SEPERATOR = _{
        ":"|"+:"|"-:"
    }
SINGEL_RANGE = {"["~CONSTANT_EXPRESSION~"]"}



//TODO
PARAMETER_DECLERATION = {TOK_PARAMETER}
    PARAMETER_DECLERATION_LIST={"#(" ~ PARAMETER_DECLERATION ~ ("," ~ PARAMETER_DECLERATION)* ~ ")"}

INTEGER_DECLERATION = {"TODO"}
REAL_DECLERATION = {"TODO"}

CONSTANT_EXPRESSION = {EXPRESSION}

EXPRESSION = {
    (   // THESE ARE TREATED AS PRIMARIES DURING OPERATOR PRECEDENCE PARSING
        ("("~EXPRESSION~")"|PRIMARY|UNARY_OPERATOR)
        ~(  /*
            BINARY OPERATORS
            OPERATOR PRECEDENCE IS PARSED DURING AST GENERATION
            PRECEDENCE HERE ENSURES THAT OPERATORS ARE FULLY PARSED: for example ~^instead of just ~
            */
            OP_CASE_EQ|OP_CASE_NE|
            OP_EQ|OP_NE|
            OP_LE|OP_LT|OP_GE|OP_GT|
            OP_LOGIC_AND|OP_LOGIC_OR|

            OP_PLUS|OP_MINUS|
            OP_POT|OP_MUL|OP_DIV|OP_MOD|

            OP_ARITHMETIC_RIGHT|OP_ARITHMETIC_LEFT|
            OP_LOGIC_LEFT|OP_LOGIC_RIGHT|

            OP_NAND|OP_NXOR|OP_NOR|
            OP_OR|OP_AND|OP_BIT_NOT|OP_XOR|

            OP_COND|

            OP_CONCAT|OP_REPLICATION)
        )*~("("~EXPRESSION~")"|PRIMARY|UNARY_OPERATOR)
}

UNARY_OPERATOR ={(OP_NAND|OP_NXOR|OP_NOR|
                    OP_OR|OP_AND|OP_XOR|
                    OP_BIT_NOT|OP_NOT|
                    OP_PLUS|OP_MINUS)
                ~(PRIMARY|"("~EXPRESSION~")")}

    PRIMARY = {REAL_NUMBER|UNSIGNED_NUMBER|HIERARCHICAL_ID}

MINTYPEMAX_EXPRESSION = {EXPRESSION|EXPRESSION~":"~EXPRESSION~":"~EXPRESSION}
EVENT_EXPRESSION = {
EXPRESSION| "TODO" ~ EXPRESSION
}






