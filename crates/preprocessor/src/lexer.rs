/*
 *  ******************************************************************************************
 *  Copyright (c) 2021 Pascal Kuthe. This file is part of the frontend project.
 *  It is subject to the license terms in the LICENSE file found in the top-level directory
 *  of this distribution and at  https://gitlab.com/DSPOM/OpenVAF/blob/master/LICENSE.
 *  No part of frontend, including this file, may be copied, modified, propagated, or
 *  distributed except according to the terms contained in the LICENSE file.
 *  *****************************************************************************************
 */

use logos::internal::LexerInternal;
use logos::Logos;
use std::fmt::{Display, Formatter};

//in terms of api this just serves as a lexer token enum. however it actually is the real lexer generated by logos.
#[derive(Clone, Logos, Debug, PartialEq, Copy, Eq, Hash)]
#[repr(u8)]
pub enum RawToken {
    //Newline handling
    #[regex(r"\\\r?\n")]
    MacroDefNewLine,

    #[token("//", process_comment)]
    Comment,

    #[token("/*", process_block_comment)]
    BlockComment,

    #[token("\n")]
    Newline,

    #[regex(r"[ \t\f\r]+")]
    WhiteSpace,

    #[error]
    Unexpected,

    #[regex(r"`[a-zA-Z_][a-zA-Z_0-9\$]*")]
    MacroCall,

    //Compiler directives
    #[token("`include")]
    Include,
    #[token("`ifdef")]
    MacroIf,
    #[token("`ifndef")]
    MacroIfn,
    #[token("`elsif")]
    MacroElsif,
    #[token("`else")]
    MacroElse,
    #[token("`endif")]
    MacroEndIf,
    #[token("`define")]
    MacroDef,

    #[token("$root")]
    Root,

    //Identifiers
    #[regex(r"[a-zA-Z_][[:word:]\$]*")]
    SimpleIdentifier,

    #[regex(r"\\[[:print:]&&\S]+")]
    EscapedIdentifier,

    #[regex(r"\$[a-zA-Z_][[:word:]\$]*")]
    SystemCall,

    //Literals
    #[regex(r#""([^\n"\\]|\\[\\tn"\n)]|\\\r\n)*""#)]
    LitString,

    #[regex(r"[0-9][0-9_]*")]
    LitInteger,

    #[regex(r"[0-9][0-9_]*\.[0-9][0-9_]*[TGMKkmunpfa]")]
    #[regex(r"[0-9][0-9_]*[TGMKkmunpfa]")]
    LitSiRealNumber,

    #[regex(r"[0-9][0-9_]*\.[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*")]
    #[regex(r"[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*")]
    #[regex(r"[0-9][0-9_]*\.[0-9][0-9_]*")]
    LitStdRealNumber,

    //Symbols
    #[token(".")]
    Dot,
    #[token(";")]
    Semicolon,
    #[token(":")]
    Colon,
    #[token(",")]
    Comma,
    #[token("(")]
    ParenOpen,
    #[token(")")]
    ParenClose,
    #[token("(*")]
    AttributeStart,
    #[token("*)")]
    AttributeEnd,
    #[token("[")]
    SquareBracketOpen,
    #[token("]")]
    SquareBracketClose,
    #[token("<+")]
    Contribute,
    #[token("=")]
    Assign,
    #[token("#")]
    Hash,

    //Arithmatic Operators
    #[token("*")]
    Mul,
    #[token("/")]
    Div,
    #[token("%")]
    Modulus,
    #[token("+")]
    Plus,
    #[token("-")]
    Minus,
    #[token("**")]
    Pow,
    #[token("<<")]
    ShiftLeft,
    #[token(">>")]
    ShiftRight,
    #[token("<<<")]
    ArithmeticShiftLeft,
    #[token(">>>")]
    ArithmeticShiftRight,

    //UnaryOperators
    #[token("!")]
    LogicNot,
    #[token("~")]
    BitNot,

    //Relational
    #[token("<")]
    Less,
    #[token("<=")]
    LessEqual,
    #[token(">")]
    Greater,
    #[token(">=")]
    GreaterEqual,
    #[token("==")]
    Equal,
    #[token("!=")]
    NotEqual,

    //Logic
    #[token("&&")]
    LogicAnd,
    #[token("||")]
    LogicalOr,

    //Bit
    #[token("&")]
    And,
    #[token("^")]
    BitXor,
    #[token("~^")]
    LNXor,
    #[token("^~")]
    RNXor,
    #[token("|")]
    Pipe,

    //Other
    #[token("?")]
    QuestionMark,

    #[token("{")]
    LBrace,

    #[token("}")]
    RBrace,

    #[token("'{")]
    ArrStart,

    #[token("@")]
    EventStart,

    //Keywords
    #[token("if")]
    If,
    #[token("else")]
    Else,
    #[token("while")]
    While,
    #[token("for")]
    For,

    #[token("case")]
    Case,
    #[token("endcase")]
    EndCase,
    #[token("default")]
    Default,

    #[token("begin")]
    Begin,
    #[token("end")]
    End,

    #[token("module")]
    Module,
    #[token("endmodule")]
    EndModule,

    #[token("discipline")]
    Discipline,
    #[token("enddiscipline")]
    EndDiscipline,

    #[token("nature")]
    Nature,
    #[token("endnature")]
    EndNature,

    #[token("branch")]
    Branch,
    #[token("parameter")]
    Parameter,

    #[token("analog")]
    Analog,
    #[token("function")]
    Function,
    #[token("endfunction")]
    EndFunction,

    #[token("input")]
    Input,
    #[token("inout")]
    Inout,
    #[token("output")]
    Output,

    //Types
    #[token("string")]
    String,
    #[token("integer")]
    Integer,
    #[token("real")]
    Real,

    #[token("reg")]
    #[token("wreal")]
    #[token("supply0")]
    #[token("supply1")]
    #[token("tri")]
    #[token("triand")]
    #[token("trior")]
    #[token("tri0")]
    #[token("tri1")]
    #[token("wire")]
    #[token("uwire")]
    #[token("wand")]
    #[token("wor")]
    #[token("ground")]
    NetType,

    // #[token("domain")]
    // Domain,
    // #[token("discrete")]
    // Discrete,
    // #[token("continuous")]
    // Continuous,
    #[token("from")]
    From,
    #[token("exclude")]
    Exclude,

    #[token("inf")]
    Infinity,

    #[token("initial_step")]
    InitialStep,

    #[token("final_step")]
    FinalStep,

    EOF,
}

#[inline]
fn process_block_comment(lex: &mut logos::Lexer<'_, RawToken>) {
    while let Some(byte) = lex.read() {
        match byte {
            b'*' => {
                lex.bump_unchecked(1);
                if lex.read() == Some(b'/') {
                    lex.bump_unchecked(1);
                    break;
                }
            }
            _ => lex.bump_unchecked(1),
        }
    }
}

#[inline]
fn process_comment(lex: &mut logos::Lexer<'_, RawToken>) {
    while let Some(byte) = lex.read() {
        match byte {
            b'\n' => break,
            _ => lex.bump_unchecked(1),
        }
    }
}

//
// #[cfg(test)]
// mod test {
//     use super::*;
//     struct TestLexer<'lt> {
//         internal: logos::Lexer<'lt, RawToken>,
//     }
//     impl<'lt> TestLexer<'lt> {
//         pub fn new(source: &'lt str) -> Self {
//             Self { internal: RawToken::lexer(source) }
//         }
//
//         pub fn next(&mut self) -> Option<RawToken> {
//             lo {
//                 match self.internal.next() {
//                     Some(RawToken::Newline) => (),
//                     res => return res,
//                 }
//             }
//         }
//
//         pub fn slice(&self) -> &str {
//             self.internal.slice()
//         }
//     }
//
//     #[test]
//     pub fn macro_if() {
//         let mut lexer = TestLexer::new("`ifdef");
//         assert_eq!(lexer.next(), Some(RawToken::MacroIf));
//     }
//     #[test]
//     pub fn macro_ifn() {
//         let mut lexer = TestLexer::new("`ifndef");
//         assert_eq!(lexer.next(), Some(RawToken::MacroIfn));
//     }
//     #[test]
//     pub fn macro_else() {
//         let mut lexer = TestLexer::new("`else");
//         assert_eq!(lexer.next(), Some(RawToken::MacroElse));
//     }
//     #[test]
//     pub fn macro_elsif() {
//         let mut lexer = TestLexer::new("`elsif");
//         assert_eq!(lexer.next(), Some(RawToken::MacroElsif));
//     }
//     #[test]
//     pub fn macro_definition() {
//         let mut lexer = TestLexer::new("`define x(y) \\\n test");
//         assert_eq!(lexer.next(), Some(RawToken::MacroDef));
//         assert_eq!(lexer.next(), Some(RawToken::SimpleIdentifier));
//         assert_eq!(lexer.next(), Some(RawToken::ParenOpen));
//         assert_eq!(lexer.next(), Some(RawToken::SimpleIdentifier));
//         assert_eq!(lexer.next(), Some(RawToken::ParenClose));
//         assert_eq!(lexer.next(), Some(RawToken::MacroDefNewLine));
//         assert_eq!(lexer.next(), Some(RawToken::SimpleIdentifier));
//     }
//     #[test]
//     pub fn include() {
//         assert_eq!(TestLexer::new("`include").next(), Some(RawToken::Include));
//     }
//     #[test]
//     pub fn simple_ident() {
//         let mut lexer = TestLexer::new("test _test  egta  test$\ntest2_$ iftest");
//         assert_eq!(lexer.next(), Some(RawToken::SimpleIdentifier));
//         assert_eq!(lexer.slice(), "test");
//         assert_eq!(lexer.next(), Some(RawToken::SimpleIdentifier));
//         assert_eq!(lexer.slice(), "_test");
//         assert_eq!(lexer.next(), Some(RawToken::SimpleIdentifier));
//         assert_eq!(lexer.slice(), "egta");
//         assert_eq!(lexer.next(), Some(RawToken::SimpleIdentifier));
//         assert_eq!(lexer.slice(), "test$");
//         assert_eq!(lexer.next(), Some(RawToken::SimpleIdentifier));
//         assert_eq!(lexer.slice(), "test2_$");
//         assert_eq!(lexer.next(), Some(RawToken::SimpleIdentifier));
//         assert_eq!(lexer.slice(), "iftest");
//     }
//     #[test]
//     pub fn escaped_ident() {
//         let mut lexer = TestLexer::new("\\lel\\\\lel \\if ");
//         assert_eq!(lexer.next(), Some(RawToken::EscapedIdentifier));
//         assert_eq!(&lexer.slice()[1..9], "lel\\\\lel");
//         assert_eq!(lexer.next(), Some(RawToken::EscapedIdentifier));
//         assert_eq!(&lexer.slice()[1..3], "if");
//     }
//     #[test]
//     pub fn comment() {
//         let mut lexer = TestLexer::new("//jdfjdfjw4$%\r%&/**#.,|\ntest");
//         assert_eq!(lexer.next(), Some(RawToken::SimpleIdentifier));
//         assert_eq!(lexer.slice(), "test")
//     }
//     #[test]
//     pub fn block_comment() {
//         let mut lexer = TestLexer::new("/*A*\n\t\n*漢字****/`test");
//
//         assert_eq!(lexer.next(), Some(RawToken::MacroCall));
//         assert_eq!(lexer.slice(), "`test")
//     }
//     #[test]
//     pub fn string() {
//         let mut lexer = TestLexer::new(r#""lel\"dsd%§.,-032391\t    ""#);
//         assert_eq!(lexer.next(), Some(RawToken::LiteralString));
//     }
//     #[test]
//     pub fn unsigned_number() {
//         let mut lexer = TestLexer::new("1_2345_5678_9");
//         assert_eq!(lexer.next(), Some(RawToken::LiteralInteger));
//     }
//     #[test]
//     pub fn macro_ref() {
//         let test = "`egta";
//
//         let mut lexer = TestLexer::new(test);
//         assert_eq!(lexer.next(), Some(RawToken::MacroCall))
//     }
//
//     #[test]
//     pub fn syscall() {
//         let test = "$temperature";
//
//         let mut lexer = TestLexer::new(test);
//         assert_eq!(lexer.next(), Some(RawToken::SystemCall))
//     }
//     #[test]
//     pub fn real_number() {
//         let mut lexer = TestLexer::new(
//             "1.2
//             0.1
//             2394.26331
//             1.2E12 // the exponent symbol can be e or E
//             1.30e-2
//             0.1e-0
//             236.123_763_e-12 // underscores are ignored
//             1.3u
//             23E10
//             29E-2
//             7k
//             30n",
//         );
//         assert_eq!(lexer.next(), Some(RawToken::LiteralRealNumber));
//         assert_eq!(lexer.next(), Some(RawToken::LiteralRealNumber));
//         assert_eq!(lexer.next(), Some(RawToken::LiteralRealNumber));
//         assert_eq!(lexer.next(), Some(RawToken::LiteralRealNumber));
//         assert_eq!(lexer.next(), Some(RawToken::LiteralRealNumber));
//         assert_eq!(lexer.next(), Some(RawToken::LiteralRealNumber));
//         assert_eq!(lexer.next(), Some(RawToken::LiteralRealNumber));
//         assert_eq!(lexer.next(), Some(RawToken::LiteralRealNumberWithScaleChar));
//         assert_eq!(lexer.next(), Some(RawToken::LiteralRealNumber));
//         assert_eq!(lexer.next(), Some(RawToken::LiteralRealNumber));
//         assert_eq!(lexer.next(), Some(RawToken::LiteralRealNumberWithScaleChar));
//         assert_eq!(lexer.next(), Some(RawToken::LiteralRealNumberWithScaleChar));
//     }
// }
// The following is used for error messages

impl Display for RawToken {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        match self {
            Self::MacroDefNewLine => f.write_str("\\ (newline)"),
            Self::Newline => f.write_str("(newline)"),
            Self::Unexpected => f.write_str("unexpected Sequence"),
            Self::Include => f.write_str("`include"),
            Self::MacroIf => f.write_str("`if"),
            Self::MacroIfn => f.write_str("`ifn"),
            Self::MacroElsif => f.write_str("`elsif"),
            Self::MacroElse => f.write_str("`else"),
            Self::MacroEndIf => f.write_str("`endif"),
            Self::Case => f.write_str("$case"),
            Self::EndCase => f.write_str("$endcase"),
            Self::MacroDef => f.write_str("`define"),
            Self::MacroCall => f.write_str("macro call (`name)"),
            Self::SimpleIdentifier => f.write_str("simple identifier"),
            Self::EscapedIdentifier => f.write_str("escaped identifier"),
            Self::LitString => f.write_str("string literal"),
            Self::LitInteger => f.write_str("unsigned number"),
            Self::LitStdRealNumber | Self::LitSiRealNumber => f.write_str("real number"),
            Self::Dot => f.write_str("."),
            Self::Semicolon => f.write_str(";"),
            Self::Colon => f.write_str(":"),
            Self::Comma => f.write_str(","),
            Self::ParenOpen => f.write_str("("),
            Self::ParenClose => f.write_str(")"),
            Self::AttributeStart => f.write_str("(*"),
            Self::AttributeEnd => f.write_str("*)"),
            Self::SquareBracketOpen => f.write_str("["),
            Self::SquareBracketClose => f.write_str("]"),
            Self::Contribute => f.write_str("<+"),
            Self::Assign => f.write_str("="),
            Self::Hash => f.write_str("#"),
            Self::Mul => f.write_str("*"),
            Self::Div => f.write_str("/"),
            Self::Modulus => f.write_str("%"),
            Self::Plus => f.write_str("+"),
            Self::Minus => f.write_str("-"),
            Self::Pow => f.write_str("**"),
            Self::LogicNot => f.write_str("!"),
            Self::BitNot => f.write_str("~"),
            Self::ShiftLeft => f.write_str("<<"),
            Self::ShiftRight => f.write_str(">>"),
            Self::ArithmeticShiftLeft => f.write_str("<<<"),
            Self::ArithmeticShiftRight => f.write_str(">>>"),
            Self::Less => f.write_str("<"),
            Self::LessEqual => f.write_str("<="),
            Self::Greater => f.write_str(">"),
            Self::GreaterEqual => f.write_str(">="),
            Self::Equal => f.write_str("=="),
            Self::NotEqual => f.write_str("!="),
            Self::LogicAnd => f.write_str("&&"),
            Self::LogicalOr => f.write_str("||"),
            Self::And => f.write_str("&"),
            Self::BitXor => f.write_str("^"),
            Self::LNXor => f.write_str("~^"),
            Self::RNXor => f.write_str("^~"),
            Self::Pipe => f.write_str("|"),
            Self::QuestionMark => f.write_str("?"),
            Self::If => f.write_str("if"),
            Self::Else => f.write_str("else"),
            Self::While => f.write_str("while"),
            Self::For => f.write_str("for"),
            Self::Begin => f.write_str("begin"),
            Self::End => f.write_str("end"),
            Self::Module => f.write_str("module"),
            Self::EndModule => f.write_str("endmodule"),
            Self::Discipline => f.write_str("discipline"),
            Self::EndDiscipline => f.write_str("enddiscipline"),
            Self::Nature => f.write_str("nature"),
            Self::EndNature => f.write_str("endnature"),
            Self::Branch => f.write_str("branch"),
            Self::Parameter => f.write_str("parameter"),
            Self::Analog => f.write_str("analog"),
            Self::Input => f.write_str("input"),
            Self::Inout => f.write_str("inout"),
            Self::Output => f.write_str("output"),
            Self::String => f.write_str("string"),
            Self::Integer => f.write_str("integer"),
            Self::Real => f.write_str("real"),
            Self::From => f.write_str("from"),
            Self::Exclude => f.write_str("exclude"),
            Self::Infinity => f.write_str("inf"),
            Self::Function => f.write_str("function"),
            Self::EndFunction => f.write_str("endfunction"),
            Self::Default => f.write_str("default"),
            Self::LBrace => f.write_str("{"),
            Self::RBrace => f.write_str("}"),
            Self::ArrStart => f.write_str("'"),
            Self::EventStart => f.write_str("@"),
            Self::SystemCall => f.write_str("system_function_call"),
            Self::NetType => f.write_str("net_type"),
            Self::Comment => f.write_str("(comment)"),
            Self::WhiteSpace => f.write_str("(whitespace)"),
            Self::BlockComment => f.write_str("(block comment)"),
            Self::Root => f.write_str("root"),
            Self::InitialStep => f.write_str("inital_step"),
            Self::FinalStep => f.write_str("final_step"),
            Self::EOF => f.write_str("EOF"),
        }
    }
}
