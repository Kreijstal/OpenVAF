//! Defines input for code generation process.

use crate::to_upper_snake_case;

pub(crate) struct KindsSrc<'a> {
    pub(crate) punct: &'a [(&'a str, &'a str)],
    pub(crate) keywords: &'a [&'a str],
    pub(crate) literals: &'a [&'a str],
    pub(crate) tokens: &'a [&'a str],
    pub(crate) nodes: &'a [&'a str],
}

pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {
    punct: &[
        (";", "SEMICOLON"),
        (",", "COMMA"),
        ("(", "L_PAREN"),
        (")", "R_PAREN"),
        ("{", "L_CURLY"),
        ("}", "R_CURLY"),
        ("[", "L_BRACK"),
        ("]", "R_BRACK"),
        ("<", "L_ANGLE"),
        (">", "R_ANGLE"),
        ("@", "AT"),
        ("#", "POUND"),
        ("~", "TILDE"),
        ("?", "QUESTION"),
        ("$", "DOLLAR"),
        ("&", "AMP"),
        ("|", "PIPE"),
        ("+", "PLUS"),
        ("*", "STAR"),
        ("/", "SLASH"),
        ("^", "CARET"),
        ("%", "PERCENT"),
        ("_", "UNDERSCORE"),
        (".", "DOT"),
        (":", "COLON"),
        ("=", "EQ"),
        ("==", "EQ2"),
        ("!", "BANG"),
        ("!=", "NEQ"),
        ("-", "MINUS"),
        ("<=", "LTEQ"),
        (">=", "GTEQ"),
        ("&&", "AMP2"),
        ("||", "PIPE2"),
        ("<<<", "ASHL"),
        (">>>", "ASHR"),
        ("<<", "SHL"),
        (">>", "SHR"),
        ("(*", "L_ATTR_PAREN"),
        ("*)", "R_ATTR_PAREN"),
        ("'{", "ARR_START"),
        ("<+", "CONTR"),
        ("**", "POW"),
        ("~^", "L_NXOR"),
        ("^~", "R_NXOR"),
    ],
    keywords: &[
        // "above",
        // "abs",
        // "absdelay",
        // "absdelta",
        // "abstol",
        // "access",
        // "acos",
        // "acosh",
        // "ac_stim",
        // "aliasparam",
        // "always",
        "analog",
        // "analysis",
        // "and",
        // "asin",
        // "asinh",
        // "assert",
        // "assign",
        // "atan",
        // "atan2",
        // "atanh",
        // "automatic",
        "begin",
        "branch",
        // "buf",
        // "bufif0",
        // "bufif1",
        "case",
        // "casex",
        // "casez",
        // "ceil",
        // "cell",
        // "cmos",
        // "config",
        // "connect",
        // "connectmodule",
        // "connectrules",
        // "continuous",
        // "cos",
        // "cosh",
        // "cross",
        // "ddt",
        // "ddt_nature",
        // "ddx",
        // "deassign",
        "default",
        // "defparam",
        // "design",
        "disable",
        "discipline",
        // "discrete",
        // "domain",
        // "driver_update",
        // "edge",
        "else",
        "end",
        "endcase",
        // "endconfig",
        // "endconnectrules",
        "enddiscipline",
        "endfunction",
        // "endgenerate",
        "endmodule",
        "endnature",
        // "endparamset",
        // "endprimitive",
        // "endspecify",
        // "endtable",
        // "endtask",
        // "event",
        "exclude",
        // "exp",
        // "final_step",
        // "flicker_noise",
        // "floor",
        // "flow",
        "for",
        // "force",
        // "forever",
        // "fork",
        "from",
        "function",
        // "generate",
        // "genvar",
        // "ground",
        // "highz0",
        // "highz1",
        // "hypot",
        // "idt",
        // "idtmod",
        // "idt_nature",
        "if",
        // "ifnone",
        // "incdir",
        // "include",
        "inf",
        // "initial",
        // "initial_step",
        "inout",
        "input",
        // "instance",
        "integer",
        // "join",
        // "laplace_nd",
        // "laplace_np",
        // "laplace_zd",
        // "laplace_zp",
        // "large",
        // "last_crossing",
        // "liblist",
        // "library",
        // "limexp",
        // "ln",
        // "localparam",
        // "log",
        // "macromodule",
        // "max",
        // "medium",
        // "merged",
        // "min",
        "module",
        // "nand",
        "nature",
        // "negedge",
        // "net_resolution",
        // "nmos",
        // "noise_table",
        // "noise_table_log",
        // "nor",
        // "noshowcancelled",
        // "not",
        // "notif0",
        // "notif1",
        // "or",
        "output",
        "parameter",
        // "paramset",
        // "pmos",
        // "posedge",
        // "potential",
        // "pow",
        // "primitive",
        // "pull0",
        // "pull1",
        // "pulldown",
        // "pullup",
        // "pulsestyle_onevent",
        // "pulsestyle_ondetect",
        // "rcmos",
        "real",
        // "realtime",
        // "reg",
        // "release",
        // "repeat",
        // "resolveto",
        // "rnmos",
        // "rpmos",
        // "rtran",
        // "rtranif0",
        // "rtranif1",
        // "scalared",
        // "sin",
        // "sinh",
        // "showcancelled",
        // "signed",
        // "slew",
        // "small",
        // "specify",
        // "specparam",
        // "split",
        // "sqrt",
        "string",
        // "strong0",
        // "strong1",
        // "supply0",
        // "supply1",
        // "table",
        // "tan",
        // "tanh",
        // "task",
        // "time",
        // "timer",
        // "tran",
        // "tranif0",
        // "tranif1",
        // "transition",
        // "tri",
        // "tri0",
        // "tri1",
        // "triand",
        // "trior",
        // "trireg",
        // "units",
        // "unsigned",
        // "use",
        // "uwire",
        // "vectored",
        // "wait",
        // "wand",
        // "weak0",
        // "weak1",
        "while",
        "root",
        // "white_noise",
        // "wire",
        // "wor",
        // "wreal",
        // "xnor",
        // "xor",
        // "zi_nd",
        // "zi_np",
        // "zi_zd",
        // "zi_zp",
    ],
    literals: &["INT_NUMBER", "STD_REAL_NUMBER", "SI_REAL_NUMBER", "STRING"],
    tokens: &[
        "ERROR",
        "IDENT",
        "SYSFUN",
        "NET_TYPE",
        "WHITESPACE",
        "COMMENT",
        // "SHEBANG",
        // "L_DOLLAR",
        // "R_DOLLAR",
    ],
    nodes: &[
        "ANALOG_BEHAVIOUR",
        "ARG",
        "ARG_LIST",
        "ARRAY_EXPR",
        "ASSIGN",
        "ASSIGN_STMT",
        "SIMPLE_STMT",
        "ASSIGN_OR_EXPR",
        "ATTR",
        "ATTR_LIST",
        "BIN_EXPR",
        "BLOCK_SCOPE",
        "BLOCK_STMT",
        "BRANCH_DECL",
        "CALL",
        "CASE",
        "CASE_STMT",
        "CONSTRAINT",
        "CONTRIBUTE_STMT",
        "DIRECTION",
        "DISCIPLINE_DECL",
        "DISCIPLINE_ATTR",
        "EVENT_STMT",
        "FOR_STMT",
        "FUNCTION",
        "FUNCTION_ARG",
        "IF_STMT",
        "LITERAL",
        "MODULE_DECL",
        "MODULE_PORT",
        "NAME",
        "NAME_REF",
        "SYS_FUN",
        "BODY_PORT_DECL",
        "NATURE_DECL",
        "NATURE_ATTR",
        "NET_DECL",
        "NETS",
        "PARAM",
        "PARAM_DECL",
        "PAREN_EXPR",
        "PATH",
        "PATH_EXPR",
        "PORT_DECL",
        "PORTS",
        "PREFIX_EXPR",
        "RANGE",
        "SELECT_EXPR",
        "TYPE",
        "VAR",
        "VAR_DECL",
        "WHILE_STMT",
        "EMPTY_STMT",
        "EXPR_STMT",
        "PORT_FLOW",
        "SOURCE_FILE",
        "FUNCTION_REF",
    ],
};

#[derive(Default, Debug)]
pub(crate) struct AstSrc {
    pub(crate) tokens: Vec<String>,
    pub(crate) nodes: Vec<AstNodeSrc>,
    pub(crate) enums: Vec<AstEnumSrc>,
}

#[derive(Debug)]
pub(crate) struct AstNodeSrc {
    pub(crate) doc: Vec<String>,
    pub(crate) name: String,
    pub(crate) traits: Vec<String>,
    pub(crate) fields: Vec<Field>,
}

#[derive(Debug, Eq, PartialEq)]
pub(crate) enum Field {
    Token(String),
    Node { name: String, ty: String, cardinality: Cardinality },
}

#[derive(Debug, Eq, PartialEq)]
pub(crate) enum Cardinality {
    Optional,
    Many,
}

#[derive(Debug)]
pub(crate) struct AstEnumSrc {
    pub(crate) doc: Vec<String>,
    pub(crate) name: String,
    pub(crate) traits: Vec<String>,
    pub(crate) variants: Vec<AstEnumVariant>,
    pub(crate) nested_variant: Option<String>,
}

#[derive(Debug)]
pub(crate) enum AstEnumVariant {
    Node(String),
    Token(String),
}

impl AstEnumVariant {
    pub(crate) fn syntax_kind(&self) -> String {
        match self {
            AstEnumVariant::Token(ref name) => format!("{}_KW", to_upper_snake_case(name)),
            AstEnumVariant::Node(ref name) => to_upper_snake_case(name),
        }
    }

    pub(crate) fn name(&self) -> &str {
        match self {
            AstEnumVariant::Node(ref name) | AstEnumVariant::Token(ref name) => name,
        }
    }
}
