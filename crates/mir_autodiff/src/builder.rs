use std::ops::Range;

use ahash::AHashMap;
use arena::{Arena, IdxRange};
use mir::builder::{InsertBuilder, InstBuilder, InstInserterBase};
use mir::{
    ControlFlowGraph, Function, Inst, InstructionData, Opcode, SourceLoc, Value, F_LN2, F_LN2_N,
    F_LOG10_E, F_ONE, F_TWO, F_ZERO, ONE,
};
use stdx::iter::zip;
use stdx::packed_option::{PackedOption, ReservedValue};

use crate::live_derivatives::LiveDerivatives;
use crate::unkowns::{FirstOrderUnkown, Unkown, Unkowns};

#[cfg(test)]
mod tests;

pub fn build_derivatives(
    func: &mut Function,
    cfg: &ControlFlowGraph,
    unkowns: &Unkowns,
    live_derivatives: &LiveDerivatives,
) -> AHashMap<(Value, FirstOrderUnkown), Value> {
    let derivative_values = unkowns
        .first_order_unkowns
        .iter_enumerated()
        .flat_map(|(unkown, (_, info))| {
            info.iter().map(move |(val, derivative)| ((*val, unkown), *derivative))
        })
        .collect();
    let mut builder = DerivativeBuilder {
        func,
        cfg,
        live_derivatives,
        unkowns,
        derivative_values,
        dst: (0u32.into(), SourceLoc::new(0)),
        phis: Vec::with_capacity(64),
    };

    builder.run();
    builder.derivative_values
}

type CacheData = [PackedOption<Value>; 2];

pub(crate) struct DerivativeBuilder<'a> {
    func: &'a mut Function,
    cfg: &'a ControlFlowGraph,

    live_derivatives: &'a LiveDerivatives,
    unkowns: &'a Unkowns,

    derivative_values: AHashMap<(Value, FirstOrderUnkown), Value>,
    dst: (Inst, SourceLoc),

    phis: Vec<(Inst, Unkown)>,
}

impl<'f> InstInserterBase<'f> for &'f mut DerivativeBuilder<'_> {
    fn data_flow_graph(&self) -> &mir::DataFlowGraph {
        &self.func.dfg
    }

    fn data_flow_graph_mut(&mut self) -> &mut mir::DataFlowGraph {
        &mut self.func.dfg
    }

    fn insert_built_inst(self, inst: Inst) -> &'f mut mir::DataFlowGraph {
        self.func.layout.append_inst(inst, self.dst.0);
        if self.func.srclocs.len() <= inst.into() {
            self.func.srclocs.resize(inst.into(), SourceLoc::default());
            self.func.srclocs.push(self.dst.1);
        } else {
            self.func.srclocs[inst] = self.dst.1;
        }
        self.dst.0 = inst;
        &mut self.func.dfg
    }
}

impl<'a> DerivativeBuilder<'a> {
    /// generates all derivatives and stores them in `self.derivative_values`
    ///
    /// Phi nodes are only cloned so that they have a return value that can be stored in
    /// `self.derivative_values`.
    ///
    /// Phis may form circular references and can therefore not be generated by a simple reverse
    /// postorder walk. Instead their edges are updated in the `build_phis` function
    pub fn run(&mut self) {
        let mut cache = BuilderCache::default();

        for bb in self.cfg.reverse_postorder(self.func) {
            let mut cursor = self.func.layout.block_inst_cursor(bb);
            while let Some(inst) = cursor.next(&self.func.layout) {
                let mut srcloc = self.func.srclocs.get(inst).copied().unwrap_or_default();
                srcloc.0 *= -1;
                self.dst = (inst, srcloc);
                self.build_inst(&mut cache);
            }
        }

        // populate phis with derivatives (now all values are either known/phi dummys)
        for (phi, unkown) in &self.phis {
            self.func.dfg.zap_inst(*phi);
            for arg in self.func.dfg.instr_args_mut(*phi) {
                *arg = Self::derivative_of_(self.unkowns, &self.derivative_values, *arg, *unkown);
            }
            self.func.dfg.update_inst_uses(*phi)
        }
    }

    fn build_inst(&mut self, bcache: &mut BuilderCache) {
        let unkowns = self.live_derivatives.of_inst(self.dst.0);

        match self.func.dfg.insts[self.dst.0] {
            // ddx calls just get replaced with the appropriate derivatives
            InstructionData::Call { func_ref, args } => {
                if let Some(ddx_unkown) = self.unkowns.callback_unkown(func_ref) {
                    let arg = args.as_slice(&self.func.dfg.insts.value_lists)[0];
                    let derivative = self.derivative_of_1(arg, ddx_unkown);
                    let res = self.func.dfg.first_result(self.dst.0);
                    self.func.dfg.replace_uses(res, derivative);
                    self.func.layout.remove_inst(self.dst.0);
                    return;
                }
            }

            // place dummy values for phis to break cycels
            // arguments are populated with derivatives later
            InstructionData::PhiNode(phi) => {
                if let Some(unkowns) = unkowns {
                    let res = self.func.dfg.first_result(self.dst.0);
                    for unkown in unkowns.iter() {
                        let prev_order = match self.unkowns.previous_order(unkown) {
                            Some(val) => self.derivative_of(res, val),
                            None => res, // 0th order is the original result
                        };
                        let unkown_ = self.unkowns.to_first_order(unkown);

                        // we do not calculate phis just yet as they may require backwards edges.
                        // Instead we just copy the phi and delay until all other derivatives are
                        // done
                        let edges: Vec<_> = self.func.dfg.phi_edges(phi).collect();
                        let val = self.ins().phi(&edges);
                        self.derivative_values.insert((prev_order, unkown_), val);

                        self.phis.push((self.dst.0, unkown))
                    }
                }

                return;
            }
            _ => (),
        }

        if let Some(unkowns) = unkowns {
            // add the original instruction
            bcache.resolved_derivatives.insert(None, ResolvedDerivative::root_instr(self.dst.0));

            for unkown in unkowns.iter() {
                let prev_order = self.unkowns.previous_order(unkown);
                let origin = bcache.resolved_derivatives[&prev_order].clone();
                let cache = self.ensure_cache(prev_order, &origin, bcache);

                let inst_start = self.func.dfg.num_insts().into();

                let base = self.unkowns.to_first_order(unkown);

                for (inst, cache_data_i) in zip(origin.instructions(), cache.data) {
                    self.inst_derivative(inst, base, bcache.cache_data[cache_data_i]);
                }

                let inst_end = self.func.dfg.num_insts().into();

                bcache.resolved_derivatives.insert(
                    Some(unkown),
                    ResolvedDerivative { instrs: inst_start..inst_end, cache_instrs: cache.instrs },
                );
            }

            bcache.clear();
        }
    }

    fn ensure_cache(
        &mut self,
        prev_order: Option<Unkown>,
        prev_order_instr: &ResolvedDerivative,
        bcache: &mut BuilderCache,
    ) -> CacheInfo {
        bcache
            .derivative_cache
            .entry(prev_order)
            .or_insert_with(|| {
                let instr_start = self.func.dfg.num_insts().into();
                let data_start = bcache.cache_data.len().into();

                let new_cache_data =
                    prev_order_instr.instructions().map(|inst| self.inst_cache(inst));
                bcache.cache_data.extend(new_cache_data);

                let instr_end = self.func.dfg.num_insts().into();
                let data_end = bcache.cache_data.len().into();

                CacheInfo {
                    instrs: instr_start..instr_end,
                    data: IdxRange::new(data_start..data_end),
                }
            })
            .to_owned()
    }

    fn ins(&mut self) -> InsertBuilder<&mut DerivativeBuilder<'a>> {
        InsertBuilder::new(self)
    }

    fn derivative_of_1(&self, val: Value, unkown: FirstOrderUnkown) -> Value {
        self.derivative_values.get(&(val, unkown)).copied().unwrap_or(F_ZERO)
    }

    fn derivative_of(&self, val: Value, unkown: Unkown) -> Value {
        Self::derivative_of_(self.unkowns, &self.derivative_values, val, unkown)
    }

    fn derivative_of_(
        unkowns: &Unkowns,
        derivative_values: &AHashMap<(Value, FirstOrderUnkown), Value>,
        mut val: Value,
        unkown: Unkown,
    ) -> Value {
        for unkown in unkowns.first_order_unkowns_rev(unkown) {
            if let Some(derivative) = derivative_values.get(&(val, unkown)) {
                val = *derivative;
            } else {
                return F_ZERO;
            }
        }

        val
    }

    fn insert_derivative(&mut self, original: Value, unkown: FirstOrderUnkown, val: Value) {
        let res = self.derivative_values.insert((original, unkown), val);
        debug_assert_eq!(res, None);
    }

    fn inst_cache(&mut self, inst: Inst) -> CacheData {
        let mut cache = [None.into(), None.into()];

        let op = self.func.dfg.insts[inst].opcode();
        let args = self.func.dfg.instr_args(inst);
        let arg0 = args.get(0).copied().unwrap_or_else(Value::reserved_value);
        let arg1 = args.get(1).copied().unwrap_or_else(Value::reserved_value);
        let res = self.func.dfg.first_result(inst);

        let val = match op {
            Opcode::Idiv => {
                let val = self.ins().imul(arg1, arg1);
                self.ins().ifcast(val)
            }
            Opcode::Fdiv => self.ins().fmul(arg1, arg1),

            // Technically not required but makes code look nicer..
            // exp(x) -> exp(x)
            Opcode::Exp => res,

            // hypot(x,y) -> (x' + y')/2hypot(x,y)
            // sqrt(x) -> 1/2sqrt(x)
            Opcode::Hypot | Opcode::Sqrt => self.ins().fmul(F_TWO, res),
            // ln(x) -> 1/x
            Opcode::Ln => arg0,
            // log(x) -> log(e)/x
            Opcode::Log => self.ins().fdiv(F_LOG10_E, arg0),
            // sin(x) -> cos(x)
            Opcode::Sin => self.ins().cos(arg0),
            // cos(x) -> -sin(x)
            Opcode::Cos => {
                let sin = self.ins().sin(arg0);
                self.ins().fneg(sin)
            }
            // tan(x) -> 1 + tan^2(x)
            Opcode::Tan => {
                let tan_2 = self.ins().fmul(res, res);
                self.ins().fadd(F_ONE, tan_2)
            }

            // asin(x) -> 1/sqrt(1-x^2)
            Opcode::Asin => {
                // sqrt(1 - x^2)
                let arg_squared = self.ins().fmul(arg0, arg0);
                let sqrt_arg = self.ins().fsub(F_ONE, arg_squared);
                self.ins().sqrt(sqrt_arg)
            }
            // acos(x) -> -1/sqrt(1-x^2)
            Opcode::Acos => {
                // sqrt(1 - x^2)
                let arg_squared = self.ins().fmul(arg0, arg0);
                let sqrt_arg = self.ins().fsub(F_ONE, arg_squared);
                let sqrt = self.ins().sqrt(sqrt_arg);
                self.ins().fneg(sqrt)
            }

            // arctan(x) -> 1/(1 + x^2)
            Opcode::Atan => {
                // 1 + x^2
                let arg_squared = self.ins().fmul(arg0, arg0);
                self.ins().fadd(F_ONE, arg_squared)
            }
            // arctan2(x,y) => (x'*y - y'*x)/(x^2+y^2)
            Opcode::Atan2 => {
                let lhs_squared = self.ins().fmul(arg0, arg0);
                let rhs_squared = self.ins().fmul(arg1, arg1);

                let bot = self.ins().fadd(lhs_squared, rhs_squared);

                let lhs_cache = self.ins().fdiv(arg1, bot);

                let rhs_cache = self.ins().fdiv(arg0, bot);

                cache[1] = rhs_cache.into();
                lhs_cache
            }

            // sinh(x) -> cosh(x)
            Opcode::Sinh => self.ins().cosh(arg0),
            // cosh(x) -> sinh(x)
            Opcode::Cosh => self.ins().sinh(arg0),

            // tanh(x) -> 1 - tanh^2(x)
            Opcode::Tanh => {
                let tan_2 = self.ins().fmul(res, res);
                self.ins().fsub(F_ONE, tan_2)
            }
            // acsinh(x) -> 1/sqrt(x^2 + 1)
            Opcode::Asinh => {
                // sqrt(1 + x^2)
                let arg_squared = self.ins().fmul(arg0, arg0);
                let sqrt_arg = self.ins().fadd(F_ONE, arg_squared);
                self.ins().sqrt(sqrt_arg)
            }
            // acosh(x) -> 1/sqrt(x^2 - 1)
            Opcode::Acosh => {
                // sqrt(x^2 - 1)
                let arg_squared = self.ins().fmul(arg0, arg0);
                let sqrt_arg = self.ins().fsub(arg_squared, F_ONE);
                self.ins().sqrt(sqrt_arg)
            }

            // arctanh(x) -> 1/(1-x^2)
            Opcode::Atanh => {
                // 1 - x^2
                let arg_squared = self.ins().fmul(arg0, arg0);
                self.ins().fsub(F_ONE, arg_squared)
            }

            // x << y = x*pow(2,y)-> ln(2) * x * y'* pow(2,y)  + x' * pow(2,y)
            // = ln(2) * y' * x<<y + x' * 1<<y
            Opcode::Ishl => {
                let res = self.ins().ifcast(res);
                let lhs_cache = self.ins().fmul(F_LN2, res);

                let rhs_cache = self.ins().ishl(ONE, arg1);
                let rhs_cache = self.ins().ifcast(rhs_cache);
                cache[1] = rhs_cache.into();

                lhs_cache
            }
            // x >> y = x*pow(2,-y)-> -ln(2) * x * y'* pow(2,-y)  + x' * pow(2,-y)
            // = -ln(2) * y' * x>>y + x' * 1>>y
            Opcode::Ishr => {
                let res = self.ins().ifcast(res);
                let lhs_cache = self.ins().fmul(F_LN2_N, res);

                let rhs_cache = self.ins().ishr(ONE, arg1);
                let rhs_cache = self.ins().ifcast(rhs_cache);
                cache[1] = rhs_cache.into();

                lhs_cache
            }

            // pow(x,y) -> (y/x * x' + ln(x) * y') * pow(x,y)
            Opcode::Pow => {
                let y_x = self.ins().fdiv(arg1, arg0);
                let lhs_cache = self.ins().fmul(y_x, res);

                let ln_x = self.ins().ln(arg0);
                let rhs_cache = self.ins().fmul(ln_x, res);

                cache[1] = rhs_cache.into();
                lhs_cache
            }
            _ => return cache,
        };

        cache[0] = val.into();

        cache
    }

    fn inst_derivative(&mut self, inst: Inst, unkown: FirstOrderUnkown, cache: CacheData) {
        let res = self.func.dfg.first_result(inst);
        let op = self.func.dfg.insts[inst].opcode();

        let args = self.func.dfg.instr_args(inst);
        let arg0 = args.get(0).copied().unwrap_or_else(Value::reserved_value);
        let arg1 = args.get(1).copied().unwrap_or_else(Value::reserved_value);
        let arg_derivatrive = |sel: &mut DerivativeBuilder, i| {
            sel.derivative_of_1(sel.func.dfg.instr_args(inst)[i], unkown)
        };

        let gen_mul_derivative =
            |sel: &mut DerivativeBuilder, mut lhs: Value, mut rhs: Value, cast: bool| {
                let drhs = arg_derivatrive(sel, 1);
                let dlhs = arg_derivatrive(sel, 0);
                let res = if cast {
                    // TODO cache
                    // TODO lazy
                    lhs = sel.ins().ifcast(lhs);
                    rhs = sel.ins().ifcast(rhs);
                    sel.ins().ifcast(res)
                } else {
                    res
                };

                let sum1 = if dlhs == F_ZERO {
                    F_ZERO
                } else if dlhs == F_ONE {
                    rhs
                } else if dlhs == lhs {
                    res
                } else {
                    sel.ins().fmul(dlhs, rhs)
                };
                let sum2 = if drhs == F_ZERO {
                    return sum1;
                } else if drhs == F_ONE {
                    lhs
                } else if drhs == rhs {
                    res
                } else {
                    sel.ins().fmul(drhs, lhs)
                };

                if dlhs == F_ZERO {
                    return sum2;
                }
                sel.ins().fadd(sum1, sum2)
            };

        // (f/g)' -> (f'*g - g' *f) / g^2 = f'/g - g'*f/g^2
        let gen_div_derivative =
            |sel: &mut DerivativeBuilder, mut lhs: Value, mut rhs: Value, cast: bool| {
                let dlhs = arg_derivatrive(sel, 0);
                let drhs = arg_derivatrive(sel, 1);
                let res = if cast {
                    lhs = sel.ins().ifcast(lhs);
                    rhs = sel.ins().ifcast(rhs);
                    sel.ins().ifcast(res)
                } else {
                    res
                };

                // f'/g
                let sum1 = if dlhs == F_ZERO {
                    F_ZERO
                } else if dlhs == lhs {
                    res
                } else {
                    sel.ins().fdiv(dlhs, rhs)
                };

                // f*g'/g^2
                let top = if drhs == F_ZERO {
                    return sum1;
                } else if drhs == F_ONE {
                    lhs
                } else if drhs == rhs {
                    if sum1 == res {
                        return F_ZERO;
                    }
                    res
                } else {
                    sel.ins().fmul(drhs, lhs)
                };
                let bot = cache[0].unwrap_unchecked();
                let sum2 = sel.ins().fdiv(top, bot);

                sel.ins().fsub(sum1, sum2)
            };

        let val = match op {
            Opcode::Fneg | Opcode::Ineg => {
                let arg = arg_derivatrive(self, 0);
                self.ins().fneg(arg)
            }

            // All derivatives are real so all casts are essentially just copies
            Opcode::IFcast
            | Opcode::BIcast
            | Opcode::IBcast
            | Opcode::FBcast
            | Opcode::BFcast
            // 0 is technically the correct thing
            // but intuetively the other thing is correct
            // TODO discuss with committee what to do with integer derivatives
            | Opcode::FIcast
            |Opcode::OptBarrier
                => arg_derivatrive(self,0),

            // TODO remove hack
            Opcode::Call  => {
            if let InstructionData::Call{func_ref,..} = self.func.dfg.insts[inst]{
                    if self.func.dfg.signatures[func_ref].name == "ddt"{
                        arg_derivatrive(self,0)
                    }else{
                        return
                    }
                }else{
                    return
                }
            }

            // TODO error?
            Opcode::Irem
            | Opcode::Inot
            | Opcode::Ixor
            | Opcode::Iand
            | Opcode::Ior
            | Opcode::Clog2
            | Opcode::Frem
            | Opcode::Floor
            | Opcode::Ceil
            | Opcode::Bnot
            | Opcode::Ilt
            | Opcode::Igt
            | Opcode::Flt
            | Opcode::Fgt
            | Opcode::Ile
            | Opcode::Ige
            | Opcode::Fle
            | Opcode::Fge
            | Opcode::Ieq
            | Opcode::Feq
            | Opcode::Seq
            | Opcode::Beq
            | Opcode::Ine
            | Opcode::Fne
            | Opcode::Sne
            | Opcode::Bne
                // zero no need to store the derivative
                => return,

            Opcode::Iadd | Opcode::Fadd => {
                let dlhs = arg_derivatrive(self, 0);
                let drhs = arg_derivatrive(self, 1);
                self.ins().fadd(dlhs, drhs)
            }

            Opcode::Isub | Opcode::Fsub => {
                let dlhs = arg_derivatrive(self, 0);
                let drhs = arg_derivatrive(self, 1);
                self.ins().fsub(dlhs, drhs)
            }

            Opcode::Imul => {
                gen_mul_derivative(self, arg0,arg1, true)
            }
            Opcode::Fmul => gen_mul_derivative(self,  arg0,arg1, false),
            // Opcode::CmplxMul
            // => gen_mul_derivative(self, Opcode::CmplxPlus, false),

            // Opcode::CmplxDiv => gen_div_derivative(self, Opcode::CmplxMinus, Opcode::CmplxMul, false),
            Opcode::Idiv => {
                gen_div_derivative(self, arg0, arg1, true)
            }
            Opcode::Fdiv => gen_div_derivative(self, arg0, arg1, false),

            Opcode::Exp
            | Opcode::Log
            | Opcode::Sin
            | Opcode::Cos
            | Opcode::Sinh
            | Opcode::Cosh
            | Opcode::Tan
            | Opcode::Tanh => {
                let darg = arg_derivatrive(self, 0);
                match darg{
                        F_ZERO => return,
                        F_ONE => cache[0].unwrap_unchecked(),
                        _ => self.ins().fmul(darg, cache[0].unwrap_unchecked()),
                }
            }

            Opcode::Ln
            |Opcode::Sqrt
            | Opcode::Asin
            | Opcode::Acos
            | Opcode::Atan
            | Opcode::Asinh
            | Opcode::Acosh
            | Opcode::Atanh =>{
                    let darg = arg_derivatrive(self, 0);
                    if darg == F_ZERO{
                        return
                    }
                    self.ins().fdiv(darg, cache[0].unwrap_unchecked())
                }

            Opcode::Pow | Opcode::Ishl | Opcode::Ishr| Opcode::Atan2
                => {
                let dlhs = arg_derivatrive(self, 0);
                let drhs = arg_derivatrive(self, 1);

                let sum1 = if dlhs == F_ZERO{
                    F_ZERO
                }else if dlhs == F_ONE{
                   cache[0].unwrap_unchecked()
                }else{
                    self.ins().fmul(dlhs, cache[0].unwrap_unchecked())
                };

                if drhs == F_ZERO{
                    sum1
                }else{
                    let sum2 = if drhs == F_ONE{
                       cache[1].unwrap_unchecked()
                    }else{
                        self.ins().fmul(drhs, cache[1].unwrap_unchecked())
                    };

                    if dlhs == F_ZERO{
                        return
                    }
                    self.ins().fadd(sum1, sum2)
                }
            }

            Opcode::Hypot => {
                let dlhs = arg_derivatrive(self, 0);
                let drhs = arg_derivatrive(self, 1);
                let sum = self.ins().fadd(dlhs, drhs);
                self.ins().fdiv(sum, cache[0].unwrap_unchecked())
            }
            Opcode::Br | Opcode::Jmp |Opcode::Phi => unreachable!(),
        };

        self.insert_derivative(res, unkown, val)
    }
}

#[derive(Debug, PartialEq, Clone, Eq, Hash)]
pub struct CacheInfo {
    instrs: Range<Inst>,
    data: IdxRange<CacheData>,
}

#[derive(Debug, PartialEq, Clone, Eq, Hash)]
pub struct ResolvedDerivative {
    instrs: Range<Inst>,
    cache_instrs: Range<Inst>,
}

impl ResolvedDerivative {
    fn root_instr(pos: Inst) -> ResolvedDerivative {
        // The original instruction (so something the user typed) never has a cache and is always the first
        // instruction.
        ResolvedDerivative {
            instrs: Inst::from(u32::from(pos))..Inst::from(u32::from(pos) + 1),
            cache_instrs: Inst::from(u32::from(pos))..Inst::from(u32::from(pos)),
        }
    }

    fn instructions(&self) -> impl Iterator<Item = Inst> {
        let instrs: Range<u32> = self.instrs.start.into()..self.instrs.end.into();
        let cache_instrs: Range<u32> = self.cache_instrs.start.into()..self.cache_instrs.end.into();
        cache_instrs.chain(instrs).map(Inst::from)
    }
}

#[derive(Default)]
pub struct BuilderCache {
    resolved_derivatives: AHashMap<Option<Unkown>, ResolvedDerivative>,
    cache_data: Arena<CacheData>,
    derivative_cache: AHashMap<Option<Unkown>, CacheInfo>,
}

impl BuilderCache {
    fn clear(&mut self) {
        self.cache_data.clear();
        self.derivative_cache.clear();
        self.resolved_derivatives.clear();
    }
}
