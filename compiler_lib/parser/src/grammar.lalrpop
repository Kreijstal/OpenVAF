//  * ******************************************************************************************
//  * Copyright (c) 2021 Pascal Kuthe. This file is part of the frontend project.
//  * It is subject to the license terms in the LICENSE file found in the top-level directory
//  *  of this distribution and at  https://gitlab.com/DSPOM/OpenVAF/blob/master/LICENSE.
//  *  No part of frontend, including this file, may be copied, modified, propagated, or
//  *  distributed except according to the terms contained in the LICENSE file.
//  * *******************************************************************************************


use std::convert::identity;
use std::vec::Vec;

use openvaf_diagnostics::MultiDiagnostic;
use openvaf_data_structures::{HashMap, index_vec::IndexVec};
use openvaf_ir::{Attribute, Attributes, AttrSpanned, Spanned, Type};
use openvaf_ast as ast;
use openvaf_ast::{Ast, BinaryOperator, Block, Branch, PortBranch, Expression, HierarchicalId, FunctionArg};
use openvaf_ir::ids::{AttributeId, BranchId, PortBranchId, IdRange, StatementId, ExpressionId, PortId, ParameterId, VariableId};
use openvaf_diagnostics::lints::Linter;
use crate::{SymbolTableBuilder, Token};
use crate::error::{Error, ErrorRecoveryExpecting, ModuleEndErrorRecovery};
use crate::lints::{AtrributeOverwritten,EventIgnored};
use openvaf_session::sourcemap::Span;
use openvaf_session::sourcemap::StringLiteral;
use openvaf_session::symbols::{Ident, kw, Symbol};
use crate::{insert_params, insert_vars};

grammar<'lt>(
    scopes: &'lt mut SymbolTableBuilder,
    ast: &'lt mut Ast,
    errors: &'lt mut MultiDiagnostic<Error>
);

// ERROR Recovery

RecoverError: () = {
    <err: !> => errors.add(err),
};

SkipExtraTokens: () = {
    => (),
    RecoverError,
};

Comma: () = {
    "," => (),
    RecoverError,
};

// COMBINATORS

#[inline]
either<true_rule,false_rule>: bool = {
    true_rule => true,
    false_rule => false,
}

// Create a spanned version of data that can span multiple tokens
#[inline]
AttrSpanned<Rule>: ast::AttrSpanned<Rule> =
    <l: @L> <attributes: ATTR> <contents: Rule> <r: @R> =>{
        AttrSpanned{
            attributes,
            contents,
            span: l.extend(r),
        }
    };


SCOPE: Ident = <IDENT> => {scopes.enter_scope(); <>};


REAL_TYPE: ()= {<"real">,<"realtime">};
INT_TYPE: ()= {<"integer">,<"time">};

// Create a spanned version of a rule that can span multiple tokens
MultiSp<Rule>: Spanned<Rule> =
    <l: @L> <rule: Rule> <r: @R> =>
        Spanned::new(rule,l.extend(r));

// Create a spanned version of a rule that can only span a single token
SingleSp<Rule>: Spanned<Rule> =
    <l: @L> <rule: Rule> <r: @R> => {
        debug_assert_eq!(l,r);
        Spanned::new(rule,l)
    };



#[inline]
List<T>: Vec<T> =
    <v:(<T> Comma)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    };

#[inline]
ListAtLeastOneWithRecover<T>: Vec<T> =
    <v:(<T> Comma)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    };

#[inline]
ListAtLeastOne<T>: Vec<T> =
    <v:(<T> ",")*> <e:T> => {
    let mut v = v;
    v.push(e);
    v
};






// Basic rules
IDENT: Ident = <span: @L> <name: "an identifier"> => Ident::new(name,span);
SYS_FUN_IDENT: Ident = <span: @L> <name: "a system function identifier"> => Ident::new(name,span);

IDENT_POT_FLOW: Ident = {
    <@L> "potential" => Ident::new(kw::potential,<>),
    <@L> "flow" => Ident::new(kw::flow,<>),
    <IDENT>
}

HIDENT: HierarchicalId =
    <v: (<IDENT> ".")*> <e: IDENT> => {
        let mut v = v;
        v.push(e);
        v.into()
    };

FunctionArgs: Vec<ExpressionId> = "(" <List<EXPR>> ")";



Attribute: Attribute = <ident: IDENT> <value: ("=" <EXPR>)?> => Attribute{ident, value};


#[inline]
ATTR: Attributes =
    <("(*" <List<Attribute>> "*)")*> => {
        let attr_start = ast.attributes.len_idx();
        let mut map: HashMap<Symbol, AttributeId>= HashMap::new();
        for attribute_list in <>{
            map.reserve(attribute_list.len());
            for attr in attribute_list{
                if let Some(id) = map.get(&attr.ident.name){
                    let old_ident = ast[*id].ident;

                    Linter::dispatch_early(Box::new(AtrributeOverwritten {
                        name: old_ident.name,
                        old: old_ident.span,
                        new: attr.ident.span,
                    }));

                    ast[*id] = attr;

                } else {
                    let name = attr.ident.name;
                    let id = ast.attributes.push(attr);
                    map.insert(name, id);
                }
            }
        }
        Attributes::new(attr_start, ast.attributes.len_idx())
    };





// EPXRESSIONS


EXPR: ExpressionId ={
    <l: @L> "'" "{" <arr: List<EXPR>> "}" <r: @R> => {
        let expr = ast::Expression::Array(arr);
        let span = l.extend(r);
        let spanned = Spanned::new(expr,span);
        ast.expressions.push(spanned)
    },

    <SelectExpr>
}

SelectExpr: ExpressionId = {
    <l: @L> <cond: LogicOrExpr> "?" <true_val: EXPR> ":" <false_val: EXPR> <r: @R> => {
        let expr = ast::Expression::Condition(cond, true_val, false_val);
        let span = l.extend(r);
        let spanned = Spanned::new(expr,span);
        ast.expressions.push(spanned)
    },

    <LogicOrExpr>
}

// Binary Operator prededance is encoded in tiers
// Each tier corresponds to a precedance lvl from the VerilogAMS standard

Tier<Op, NextTier>: ExpressionId = {

    <lhs: Tier<Op, NextTier>> <op: SingleSp<Op>> <rhs: NextTier> => {
        let expr = ast::Expression::BinaryOperator(lhs,op,rhs);
        let span = ast[lhs].span.extend(ast[rhs].span);
        let spanned = Spanned::new(expr,span);
        ast.expressions.push(spanned)
    },

    NextTier
};



LogicOr: BinaryOperator = "||" => BinaryOperator::LogicOr;
LogicOrExpr = Tier<LogicOr,LogicAndExpr>;

LogicAnd: BinaryOperator = "&&" => BinaryOperator::LogicAnd;
LogicAndExpr = Tier<LogicAnd, OrExpr>;

Or: BinaryOperator = "|" => BinaryOperator::Or;
OrExpr = Tier<Or, XorExpr>;

Xor: BinaryOperator = {
    "^" => BinaryOperator::Xor,
    "~^" => BinaryOperator::NXor,
}
XorExpr = Tier<Xor, AndExpr>;

And: BinaryOperator = "&" => BinaryOperator::And;
AndExpr = Tier<And, EqualityExpr>;


Equality: BinaryOperator = {
    "==" => BinaryOperator::LogicEqual,
    "!=" => BinaryOperator::LogicalNotEqual,
}
EqualityExpr = Tier<Equality, ComparisonExpr>;

Comparison: BinaryOperator = {
    "<" => BinaryOperator::LessThen,
    "<=" => BinaryOperator::LessEqual,
    ">" => BinaryOperator::GreaterThen,
    ">=" => BinaryOperator::GreaterEqual,
}
ComparisonExpr = Tier<Comparison, ShiftExpr>;

Shift: BinaryOperator = {
    "<<" => BinaryOperator::ShiftLeft,
    ">>" => BinaryOperator::ShiftRight,
}
ShiftExpr = Tier<Shift, SumExpr>;

Sum: BinaryOperator = {
    "+" => BinaryOperator::Plus,
    "-" => BinaryOperator::Minus,
}
SumExpr = Tier<Sum, FactorExpr>;

Factor: BinaryOperator = {
    "*" => BinaryOperator::Multiply,
    "/" => BinaryOperator::Divide,
}
FactorExpr = Tier<Factor, ModulusExpr>;


Modulus: BinaryOperator = "%" => BinaryOperator::Modulus;
ModulusExpr = Tier<Modulus, ExponentExpr>;

Exponent: BinaryOperator = "**" => BinaryOperator::Exponent;
ExponentExpr = Tier<Exponent, NonBinaryExpression>;


NonBinaryExpression: ExpressionId = {

    <op: SingleSp<UnaryOp>> <val:NonBinaryExpression> => {
        let expr = ast::Expression::UnaryOperator(op,val);
        let span = op.span.extend(ast[val].span);
        let spanned = Spanned::new(expr,span);
        ast.expressions.push(spanned)
    },

    // Explicit positive can be ignored
    "+" <NonBinaryExpression>,

    <MultiSp<Primary>> => {
        let expr = ast::Expression::Primary(<>.contents);
        let spanned = Spanned::new(expr,<>.span);
        ast.expressions.push(spanned)
    },

    "(" <EXPR> ")",
}

UnaryOp: ast::UnaryOperator = {
    "!" => ast::UnaryOperator::LogicNegate,
    "~" => ast::UnaryOperator::BitNegate,
    "-" => ast::UnaryOperator::ArithmeticNegate,
}


Primary: ast::Primary = {

    //Literals
    <"a string literal"> => <>.into(),
    <"a real number"> => <>.into(),
    <"an integer"> => <>.into(),

    // Reference
    <HIDENT> => <>.into(),

    // System funcion call
    <ident: SYS_FUN_IDENT> <args: FunctionArgs> => ast::Primary::FunctionCall(ident, args.into()),
    <ident: SYS_FUN_IDENT> => ast::Primary::FunctionCall(ident, IndexVec::new()),
    <ident: IDENT_POT_FLOW> <args: FunctionArgs> => ast::Primary::FunctionCall(ident, args.into()),

    // TODO better errors
    <nature: IDENT_POT_FLOW> "(" "<" <port: HIDENT> ">" ")" => ast::Primary::PortFlowProbe(nature,port),
}


// Statements
STMT = REST_STMT<"I">;
REST_STMT<I>: StatementId = <AttrSpanned<raw_stmt<I>>> => ast.statements.push(<>);

#[inline]
ASSIGNMENT: (HierarchicalId, ExpressionId) = <(<HIDENT> "=" <EXPR>)>;

raw_stmt<I>: ast::Statement = {
    // Simple stmts

    <res: ASSIGNMENT> <r: @R> <err: !?> ";" => {
        if let Some(err) = err{
            errors.add(ErrorRecoveryExpecting(err,r,Token::Semicolon));
        }
        ast::Statement::Assignment( res.0, res.1)
    },

    <ident: SYS_FUN_IDENT> <args: FunctionArgs> ";" => ast::Statement::FunctionCall(ident, args.into()),
    <ident: IDENT_POT_FLOW> <args: FunctionArgs> ";" => ast::Statement::FunctionCall(ident, args.into()),
    <ident: SYS_FUN_IDENT> ";" => ast::Statement::FunctionCall(ident, IndexVec::new()),

    // we accept all expressions here because it allows for significantly improved errors
    // distinguishing branch probes from function calls needs to be done for expressions anyway so we just relegate that completly to HIR lowering
    <expr: EXPR> "<+" <val: EXPR> <r: @R> <err: !?> ";" => {
        if let Some(err) = err{
            errors.add(ErrorRecoveryExpecting(err,r,Token::Semicolon));
        }
        ast::Statement::Contribute(expr,val)
    },

    //control flow

    "if" "(" <cond: EXPR> ")" <true_body: STMT> if I == "I"  => ast::Statement::Condition(cond, true_body, None),

    "if" "(" <cond: EXPR> ")" <true_body: REST_STMT<"">> "else" <false_body: REST_STMT<I>> => ast::Statement::Condition(cond, true_body, Some(false_body)),

    "while" "(" <cond: EXPR> ")" <body: REST_STMT<I>> => ast::Statement::While(cond, body),


    "for" "(" <init: ASSIGNMENT> ";" <cond: EXPR> ";" <incr: ASSIGNMENT>  ")" <body: REST_STMT<I>> => {
        let for_loop = ast::ForLoop{
            init,
            cond,
            incr,
            body,
        };

        ast::Statement::For(for_loop)
    },

    "case" "(" <cond: EXPR> ")" <cases: MultiSp<case_item>*> "endcase" => ast::Statement::Case(cond, cases),

    <BLOCK>,

    // Error recovery rules
    "if" RecoverError BLOCK if I == "I"  => ast::Statement::Error,

    "if" RecoverError BLOCK "else" REST_STMT<I> => ast::Statement::Error,

    "while" RecoverError BLOCK => ast::Statement::Error,

    "for" RecoverError BLOCK => ast::Statement::Error,

    <err: !> ";" => {
        if matches!(err.error,::lalrpop_util::ParseError::UnrecognizedToken{token: (_,Token::Semicolon,_), expected: _}) && err.dropped_tokens.is_empty() {
            ast::Statement::NoOp
        }else{
            errors.add(err);
            ast::Statement::Error
        }

    },


    "case" RecoverError case_item* SkipExtraTokens "endcase" => ast::Statement::Error,

}

#[inline]
EVENT: () = "@" "(" <IDENT> ")" => {
    Linter::dispatch_early(Box::new(EventIgnored(<>)));
};

#[inline]
BLOCK: ast::Statement = "begin" <scope: block_scope?> <statements: STMT*> <err: !?> <r: @R> "end" => {
    if let Some(err) = err{
        errors.add(ErrorRecoveryExpecting(err,r,Token::Semicolon));
    }
    let block = Block{
        scope,
        statements,
    };

    let id = ast.blocks.push(block);
    ast::Statement::Block(id)
};




#[inline]
block_scope: ast::BlockScope = ":" <ident: SCOPE> block_item_declaration* => ast::BlockScope{ident, symbols: scopes.exit_scope()};

#[inline]
block_item_declaration: () = {
    PARAM_DECL,
    VAR_DECL,
}


case_item: ast::CaseItem = {
    <values: ListAtLeastOneWithRecover<EXPR>> ":" <stmt: STMT> => ast::CaseItem{values, stmt: Some(stmt)},
    <values: ListAtLeastOneWithRecover<EXPR>> ":" ";" => ast::CaseItem{values, stmt: None},

    // default case is encoded as a case item without values
    "default" ":"? <stmt: STMT> => ast::CaseItem{values: vec![], stmt: Some(stmt)},
    "default" ":"? ";" => ast::CaseItem{values: vec![], stmt: None},

};



// Items



#[inline]
PARAM_DECL: () = {
    <res: AttrSpanned< ("parameter" REAL_TYPE <ListAtLeastOne<NumericalParameter>> )>> <r: @R> <err: !?> ";" => {
        if let Some(err) = err{
            errors.add(ErrorRecoveryExpecting(err,r,Token::Semicolon));
        }
        insert_params(ast, errors, scopes, res, ast::ParameterConstraints::Ordered, Type::REAL)
    },


    <res: AttrSpanned< ("parameter" INT_TYPE <ListAtLeastOne<NumericalParameter>> ) >> <r: @R> <err: !?> ";" => {
        if let Some(err) = err{
            errors.add(ErrorRecoveryExpecting(err,r,Token::Semicolon));
        }
        insert_params(ast, errors, scopes, res,ast::ParameterConstraints::Ordered, Type::INT)
    },

    <res: AttrSpanned< ("parameter" "string" <ListAtLeastOne<StringParameter>> )>> <r: @R> <err: !?> ";" => {
        if let Some(err) = err{
            errors.add(ErrorRecoveryExpecting(err,r,Token::Semicolon));
        }
        insert_params(ast, errors, scopes, res, ast::ParameterConstraints::Unordered, Type::STRING)
    },
}




NumericalParameter: (Ident, ExpressionId, Vec<ast::OrderedParameterConstraint>) = <(<IDENT> "=" <EXPR> <numeric_value_range*>)>;
StringParameter: (Ident, ExpressionId, Vec<ast::UnorderedParameterConstraint>) = <(<IDENT> "=" <EXPR> <string_value_range*>)>;

numeric_value_range: ast::OrderedParameterConstraint = {
    "from" <numeric_param_range> => ast::ParameterConstraint::From(<>),
    "exclude" <numeric_param_range> => ast::ParameterConstraint::Exclude(<>.into()),
    "exclude" <EXPR> => ast::ParameterConstraint::Exclude(<>.into()),
}

string_value_range: ast::UnorderedParameterConstraint = {
    "from" <EXPR> => ast::ParameterConstraint::From(<>),
    "exclude" <EXPR> => ast::ParameterConstraint::Exclude(<>),
}

numeric_param_range: ast::ParameterRangeConstraint<ExpressionId> =
    <lo_inclusive: either<"[","(">> <lo: value_range_expr> ":" <hi:value_range_expr> <hi_inclusive: either<"]",")">>  => {
        let lo = ast::ParameterRangeConstraintBound{bound: lo, inclusive: lo_inclusive};
        let hi = ast::ParameterRangeConstraintBound{bound: hi, inclusive: hi_inclusive};
        lo..hi
    };

#[inline]
value_range_expr: ExpressionId = {
    <@L> "inf" => {
        let expr = Expression::Primary( f64::INFINITY.into());
        let spanned = Spanned::new(expr,<>);
        ast.expressions.push(spanned)
    },

    <@L> "-inf" => {
        let expr = Expression::Primary((-f64::INFINITY).into());
        let spanned = Spanned::new(expr,<>);
        ast.expressions.push(spanned)
    },

    <EXPR>
};


TYPE: Type = {
    REAL_TYPE => Type::REAL,
    INT_TYPE => Type::INT,
    "string" => Type::STRING,
}

#[inline]
VAR_DECL: () =
    <res: AttrSpanned< (<TYPE> <ListAtLeastOne<var_declaration>>) >>  <r: @R> <err: !?> ";" => {
        if let Some(err) = err{
            errors.add(ErrorRecoveryExpecting(err,r,Token::Semicolon));
        }
        insert_vars(ast, errors, scopes,res);
    };




var_declaration = (<IDENT> <("=" <EXPR>)?>);




#[inline]
PORT_DECL: () = {
    <res: AttrSpanned<(<DIRECTION> <IDENT?> <net_type?>  <ListAtLeastOne<IDENT>>)>> => {
        for ident in res.contents.3{

            let net = ast::Net{
                ident,
                discipline: res.contents.1,
                net_type: res.contents.2,
            };

            let net = AttrSpanned{
                contents: net,
                attributes: res.attributes,
                span: res.span
            };
            let id = ast.nets.push(net);

            let port = ast::Port{
                input: (res.contents.0).0,
                output: (res.contents.0).1,
                net: id
            };

            let id = ast.ports.push(port);

            scopes.insert(ast,errors,id)

        }
    },



}

DIRECTION: (bool,bool) = {
    "input" => (true,false),
    "output" => (false,true),
    "inout" => (true,true),
}



NET_DECL: () =
    <res: AttrSpanned<raw_net>> <r: @R> <err: !?> ";" => {
        if let Some(err) = err{
            errors.add(ErrorRecoveryExpecting(err,r,Token::Semicolon));
        }
        for ident in res.contents.2{
            let net = ast::Net{
                ident,
                discipline: res.contents.1,
                net_type: res.contents.0,
            };
            let net = AttrSpanned{
                contents: net,
                attributes: res.attributes,
                span: res.span
            };
            scopes.insert_net(ast,errors, net);
        }
    };



raw_net: (Option<Ident>, Option<Ident>, Vec<Ident>) = {
    <net_type: net_type> <discipline: IDENT?> <names: ListAtLeastOne<IDENT>> => (Some(net_type), discipline, names),
    <discipline: IDENT> <names: ListAtLeastOne<IDENT>> => (None, Some(discipline), names),
}

net_type: Ident = <span: @L> <name: "net type"> => Ident::new(name,span);

BRANCH_DECL: () = {
    <res: AttrSpanned<("branch" "(" <HIDENT> <("," <HIDENT>)?> ")" <ListAtLeastOne<IDENT>>)>> <r: @R> <err: !?> ";" => {
        if let Some(err) = err{
            errors.add(ErrorRecoveryExpecting(err,r,Token::Semicolon));
        }
        for ident in res.contents.2{
            let branch = Branch{
                ident,
                hi_net: res.contents.0.clone(),
                lo_net: res.contents.1.clone(),
            };

            let branch = AttrSpanned{
                attributes: res.attributes,
                span: res.span,
                contents: branch,
            };

            let id = ast.branches.push(branch);
            scopes.insert(ast, errors, id);
        }
    },

    <res: AttrSpanned<("branch" "(" "<" <HIDENT> ">" ")" <ListAtLeastOne<IDENT>>)>> <r: @R> <err: !?> ";" => {
        if let Some(err) = err{
            errors.add(ErrorRecoveryExpecting(err,r,Token::Semicolon));
        }
        for ident in res.contents.1{
            let port_branch = PortBranch{
                ident,
                port: res.contents.0.clone()
            };

            let port_branch = AttrSpanned{
                attributes: res.attributes,
                span: res.span,
                contents: port_branch
            };

            let id = ast.port_branches.push(port_branch);
            scopes.insert(ast, errors, id);
        }
    }
}

FUNC_DECL: () = <AttrSpanned<raw_function>> => {
    let id = ast.functions.push(<>);
    scopes.insert(ast,errors, id);
};

func_scope: (Ident, VariableId) = <IDENT> => (<>,scopes.enter_function_scope(<>,ast));

raw_function: ast::Function = {
    "function" <return_type: TYPE?> <ident_and_var: func_scope> SkipExtraTokens ";"
        <declarations: function_item_decl*>
        <body: STMT>
    "endfunction" => {
        let (ident, return_variable) = ident_and_var;
        let args = declarations
            .into_iter()
            .flatten()
            .collect();

        if let Some(return_type) = return_type{
            ast[return_variable].contents.ty = return_type;
        }

        ast::Function{
            ident,
            args,
            declarations: scopes.exit_scope(),
            body,
            return_variable,
        }
    }
}

function_item_decl: Vec<FunctionArg> = {
    block_item_declaration => Vec::new(),
    <direction: DIRECTION> <idents: ListAtLeastOne<IDENT>> ";" =>
        idents.into_iter().map(|ident|FunctionArg{
            ident,
            input: direction.0,
            output: direction.1,
        }).collect()
}

MODULE: () = <AttrSpanned<raw_module>> => {
    let id = ast.modules.push(<>);
    scopes.insert(ast,errors, id);
};


raw_module: ast::Module = "module" <ident: SCOPE> <ports: MultiSp<module_ports>> SkipExtraTokens ";" <body_start: module_start> <analog_stmts: module_body>  => {
    let symbol_table = scopes.exit_scope();
    let branches = IdRange(body_start.0..ast.branches.len_idx());
    let analog_stmts = analog_stmts.into_iter().filter_map(identity).collect();
    let body_ports = IdRange(body_start.1..ast.ports.len_idx());
    let port_branches = IdRange(body_start.2..ast.port_branches.len_idx());
    let parameters = IdRange(body_start.3..ast.parameters.len_idx());
    ast::Module{
        ident,
        symbol_table,
        branches,
        port_branches,
        body_ports,
        parameters,
        analog_stmts,
        ports,
    }
};

module_start: (BranchId, PortId, PortBranchId, ParameterId) = => (ast.branches.len_idx(), ast.ports.len_idx(), ast.port_branches.len_idx(), ast.parameters.len_idx());

module_body: Vec<Option<StatementId>> = {
    <module_item*> "endmodule",
    <res: module_item*> "analog" <r: @R> <err: !> "endmodule" => {
        errors.add(ModuleEndErrorRecovery(err,r));
        res
    },

}

#[inline]
module_item: Option<StatementId> = {
    "analog" <STMT> => Some(<>),
    "analog" FUNC_DECL => None,

    BRANCH_DECL => None,

    NET_DECL => None,

    VAR_DECL =>  None,

    PORT_DECL <r: @R> <err: !?> ";" => {
        if let Some(err) = err{
            errors.add(ErrorRecoveryExpecting(err,r,Token::Semicolon));
        }
        None
    },

    PARAM_DECL => None,
};

port_list_start: PortId = => ast.ports.len_idx();

module_ports: ast::PortList = {
    <port_list_start> ("("  List<PORT_DECL> ")")?  => <>.into(),
    port_list_start "(" <ListAtLeastOne<IDENT>> ")" => <>.into()
};

DISCIPLINE: () = <AttrSpanned<raw_discipline>> => {
    let id = ast.disciplines.push(<>);
    scopes.insert(ast,errors,id);
};

raw_discipline: ast::Discipline =
    "discipline" <ident: IDENT> (SkipExtraTokens ";")?
        <items: MultiSp<discipline_item>*>
    "enddiscipline" =>
        ast::Discipline{ident, items};


discipline_item: ast::DisciplineItem = {
    "potential" <IDENT> ";" => ast::DisciplineItem::Potential(<>),
    "flow" <IDENT> ";" => ast::DisciplineItem::Flow(<>),
    "domain" "discrete" ";" => ast::DisciplineItem::Domain(false),
    "domain" "continuous" ";" => ast::DisciplineItem::Domain(true),
    RecoverError =>  ast::DisciplineItem::Error,
};

NATURE: () = <AttrSpanned<raw_nature>> => {
    let id = ast.natures.push(<>);
    scopes.insert(ast,errors,id);
};

raw_nature: ast::Nature =
    "nature" <ident: IDENT> <parent: (":" <IDENT>)?> (SkipExtraTokens ";")?
        <attributes: nature_attribute*>
    "endnature" =>
    ast::Nature{ident, parent, attributes};

nature_attribute: Option<Spanned<(Ident,ExpressionId)>> = {
    < MultiSp<(<IDENT> "=" <EXPR> ";")> > => Some(<>),
    RecoverError => None,
};


pub Top: () = root_item*;

root_item = {
    MODULE,
    RecoverError,
    DISCIPLINE,
    NATURE,
}


extern {
    type Location = Span ;
    type Error = ();

    enum Token {
        "an identifier" => Token::Ident(<Symbol>),
        "a system function identifier" => Token::SystemFunctionIdent(<Symbol>),
        "a string literal" =>  Token::LiteralString(<StringLiteral>),
        "a real number" =>  Token::RealLiteral(<f64>),
        "an integer" =>  Token::IntLiteral(<u32>),

        "net type" => Token::NetType(<Symbol>),

        "." => Token::Accessor,
        ";" => Token::Semicolon,
        ":" => Token::Colon,
        "," => Token::Comma,
        "(" => Token::ParenOpen,
        ")" => Token::ParenClose,
        "(*" => Token::AttributeStart,
        "*)" => Token::AttributeEnd,
        "[" => Token::SquareBracketOpen,
        "]" => Token::SquareBracketClose,
        "<+" => Token::Contribute,
        "=" => Token::Assign,
        "#" => Token::Hash,

        "*" => Token::OpMul,
        "/" => Token::OpDiv,
        "%" => Token::OpModulus,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "**" => Token::OpExp,
        "!" => Token::OpLogicNot,
        "~" => Token::OpBitNot,

        "<<" => Token::OpArithmeticShiftLeft,
        ">>" => Token::OpArithmeticShiftRight,

        "<" => Token::OpLess,
        "<=" => Token::OpLessEqual,
        ">" => Token::OpGreater,
        ">=" => Token::OpGreaterEqual,
        "==" => Token::OpEqual,
        "!=" => Token::OpNotEqual,
        "&&" => Token::OpLogicAnd,
        "||" => Token::OpLogicalOr,

        "&" => Token::OpBitAnd,
        "^" => Token::OpBitXor,
        "~^" => Token::OpBitNXor,
        "|" => Token::OpBitOr,

        "?" => Token::OpCondition,
        "{" => Token::ConcatStart,
        "}" => Token::ConcatEnd,
        "'" => Token::ArrStart,

        //Keywords
        "if" => Token::If,
        "else" => Token::Else,
        "case" => Token::Case,
        "endcase" => Token::EndCase,
        "default" => Token::Default,

        "while" => Token::While,
        "for" => Token::For,

        "begin" => Token::Begin,
        "end" => Token::End,

        "module" => Token::Module,
        "endmodule" => Token::EndModule,
        "discipline" => Token::Discipline,
        "enddiscipline" => Token::EndDiscipline,

        "nature" => Token::Nature,
        "endnature" => Token::EndNature,

        "branch" => Token::Branch,
        "parameter" => Token::Parameter,
        "defparam" => Token::DefineParameter,
        "localparam" => Token::LocalParameter,

        "analog" => Token::Analog,
        "function" => Token::Function,
        "endfunction" => Token::EndFunction,
        "inital" => Token::AnalogInitial,

        "input" => Token::Input,
        "inout" => Token::Inout,
        "output" => Token::Output,

        "signed" => Token::Signed,
        "vectored" => Token::Vectored,
        "scalared" => Token::Scalared,

        //Types
        "string" => Token::String,
        "time" => Token::Time,
        "realtime" => Token::Realtime,
        "integer" => Token::Integer,
        "real" => Token::Real,

        "potential" => Token::Potential,
        "flow" => Token::Flow,
        "domain" => Token::Domain,
        "discrete" => Token::Discrete,
        "continuous" => Token::Continuous,


        "from" => Token::From,
        "exclude" => Token::Exclude,
        "inf" => Token::Infinity,
        "-inf" => Token::MinusInfinity,
        "@" => Token::EventStart,

    }
}
