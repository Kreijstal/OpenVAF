/*
 *  ******************************************************************************************
 *  Copyright (c) 2021 Pascal Kuthe. This file is part of the frontend project.
 *  It is subject to the license terms in the LICENSE file found in the top-level directory
 *  of this distribution and at  https://gitlab.com/DSPOM/OpenVAF/blob/master/LICENSE.
 *  No part of frontend, including this file, may be copied, modified, propagated, or
 *  distributed except according to the terms contained in the LICENSE file.
 *  *****************************************************************************************
 */

use logos::internal::LexerInternal;
use logos::{Filter, Logos, Skip};

use crate::error::Error::{MissingOrUnexpectedToken, MissingToken, MissingTokenAtEnd};
use crate::lexer::Token::SimpleIdentifier;
use logos::Filter::Emit;
use openvaf_session::sourcemap::span::SpanData;
use openvaf_session::sourcemap::Span;
use openvaf_session::sourcemap::{BytePos, SyntaxContext};
use openvaf_session::symbols::Ident;
use std::fmt::{Display, Formatter};

#[derive(Clone, Debug, PartialEq, Copy, Eq)]
pub struct FollowedByBracket(pub bool);

//in terms of api this just serves as a lexer token enum. however it actually is the real lexer generated by logos.
#[derive(Clone, Logos, Debug, PartialEq, Copy, Eq)]
pub enum Token {
    //Newline handling
    #[regex(r"\\\r?\n")]
    MacroDefNewLine,

    #[token("//", process_comment)]
    #[token("\n")]
    Newline,

    //Actual Tokens
    #[token("/*", skip_block_comment)]
    #[regex(r"[ \t\f\r]+", logos::skip)]
    #[error]
    Unexpected,

    #[regex(r"`[a-zA-Z_][a-zA-Z_0-9\$]*", followed_by_bracket)]
    MacroCall(FollowedByBracket),
    //Compiler directives
    #[token("`include")]
    Include,
    #[token("`ifdef")]
    MacroIf,
    #[token("`ifndef")]
    MacroIfn,
    #[token("`elsif")]
    MacroElsif,
    #[token("`else")]
    MacroElse,
    #[token("`endif")]
    MacroEndIf,
    #[token("`define")]
    MacroDef,

    //Identifiers
    #[regex(r"[a-zA-Z_][[:word:]\$]*", followed_by_bracket)]
    SimpleIdentifier(FollowedByBracket),
    #[regex(r"\\[[:print:]&&\S]+\s")]
    EscapedIdentifier,
    #[regex(r"\$[a-zA-Z_][[:word:]\$]*")]
    SystemCall,

    //Literals
    #[regex(r#""([^\n"\\]|\\[\\tn"\n)]|\\\r\n)*""#)]
    LiteralString,

    #[regex(r"[0-9][0-9_]*")]
    LiteralInteger,
    #[regex(r"[0-9][0-9_]*\.[0-9][0-9_]*[TGMKkmunpfa]")]
    #[regex(r"[0-9][0-9_]*[TGMKkmunpfa]")]
    LiteralRealNumberWithScaleChar,
    #[regex(r"[0-9][0-9_]*\.[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*")]
    #[regex(r"[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*")]
    #[regex(r"[0-9][0-9_]*\.[0-9][0-9_]*")]
    LiteralRealNumber,

    //Symbols
    #[token(".")]
    Accessor,
    #[token(";")]
    Semicolon,
    #[token(":")]
    Colon,
    #[token(",")]
    Comma,
    #[token("(")]
    ParenOpen,
    #[token(")")]
    ParenClose,
    #[token("(*")]
    AttributeStart,
    #[token("*)")]
    AttributeEnd,
    #[token("[")]
    SquareBracketOpen,
    #[token("]")]
    SquareBracketClose,
    #[token("<+")]
    Contribute,
    #[token("=")]
    Assign,
    #[token("#")]
    Hash,

    //Arithmatic Operators
    #[token("*")]
    OpMul,
    #[token("/")]
    OpDiv,
    #[token("%")]
    OpModulus,
    #[token("+")]
    Plus,
    #[token("-")]
    Minus,
    #[token("**")]
    OpExp,
    //UnaryOperators
    #[token("!")]
    OpLogicNot,
    #[token("~")]
    OpBitNot,

    #[token("<<")]
    OpArithmeticShiftLeft,
    #[token(">>")]
    OpArithmeticShiftRight,

    //Relational
    #[token("<")]
    OpLess,
    #[token("<=")]
    OpLessEqual,
    #[token(">")]
    OpGreater,
    #[token(">=")]
    OpGreaterEqual,
    #[token("==")]
    OpEqual,
    #[token("!=")]
    OpNotEqual,
    //Logic
    #[token("&&")]
    OpLogicAnd,
    #[token("||")]
    OpLogicalOr,

    //Bit
    #[token("&")]
    OpBitAnd,
    #[token("^")]
    OpBitXor,
    #[token("~^")]
    #[token("^~")]
    OpBitNXor,
    #[token("|")]
    OpBitOr,

    //Other
    #[token("?")]
    OpCondition,

    #[token("{")]
    ConcatStart,

    #[token("}")]
    ConcatEnd,

    #[token("'")]
    ArrStart,

    //Keywords
    #[token("if")]
    If,
    #[token("else")]
    Else,

    #[token("while")]
    While,
    #[token("for")]
    For,
    #[token("case")]
    Case,
    #[token("endcase")]
    EndCase,
    #[token("default")]
    Default,

    #[token("begin")]
    Begin,
    #[token("end")]
    End,

    #[token("module")]
    Module,
    #[token("endmodule")]
    EndModule,
    #[token("discipline")]
    Discipline,
    #[token("enddiscipline")]
    EndDiscipline,

    #[token("nature")]
    Nature,
    #[token("endnature")]
    EndNature,

    #[token("branch")]
    Branch,
    #[token("parameter")]
    Parameter,
    #[token("localparam")]
    DefineParameter,
    #[token("defparam")]
    LocalParameter,

    #[token("analog")]
    Analog,
    #[token("function")]
    Function,
    #[token("endfunction")]
    EndFunction,
    #[token("initial")]
    AnalogInitial,

    #[token("input")]
    Input,
    #[token("inout")]
    Inout,
    #[token("output")]
    Output,

    #[token("signed")]
    Signed,
    #[token("vectored")]
    Vectored,
    #[token("scalared")]
    Scalared,

    //Types
    #[token("string")]
    String,
    #[token("time")]
    Time,
    #[token("realtime")]
    Realtime,
    #[token("integer")]
    Integer,
    #[token("real")]
    Real,

    #[token("reg")]
    #[token("wreal")]
    #[token("supply0")]
    #[token("supply1")]
    #[token("tri")]
    #[token("triand")]
    #[token("trior")]
    #[token("tri0")]
    #[token("tri1")]
    #[token("wire")]
    #[token("uwire")]
    #[token("wand")]
    #[token("wor")]
    #[token("ground")]
    NetType,

    #[token("potential")]
    Potential,
    #[token("flow")]
    Flow,
    #[token("domain")]
    Domain,
    #[token("discrete")]
    Discrete,
    #[token("continuous")]
    Continuous,

    #[token("from")]
    From,
    #[token("exclude")]
    Exclude,
    #[token("inf")]
    Infinity,
    #[token("-inf")]
    MinusInfinity,

    #[token("@")]
    EventStart,
}

#[inline]
fn followed_by_bracket(lex: &mut logos::Lexer<'_, Token>) -> FollowedByBracket {
    FollowedByBracket(lex.read() == Some(b'('))
}
#[inline]
fn skip_block_comment(lex: &mut logos::Lexer<'_, Token>) -> Skip {
    while let Some(byte) = lex.read() {
        match byte {
            b'*' => {
                lex.bump_unchecked(1);
                if lex.read() == Some(b'/') {
                    lex.bump_unchecked(1);
                    break;
                }
            }
            _ => lex.bump_unchecked(1),
        }
    }
    Skip
}

#[inline]
fn process_comment(lex: &mut logos::Lexer<'_, Token>) -> Filter<()> {
    while let Some(byte) = lex.read() {
        match byte {
            b'\n' => return Emit(()),
            b'\\' => {
                lex.bump(1);
                if let Some(b'\n') = lex.read() {
                    return Filter::Skip;
                }
            }
            _ => lex.bump_unchecked(1),
        }
    }
    Emit(())
}

pub struct Lexer<'lt> {
    pub internal: logos::Lexer<'lt, Token>,
    lookahead: Option<<Self as Iterator>::Item>,
    pub ctxt: SyntaxContext,
    pub offset: BytePos,
}
impl<'lt> Lexer<'lt> {
    pub fn new(source: &'lt str, ctxt: SyntaxContext, offset: BytePos) -> Self {
        Self {
            internal: Token::lexer(source),
            lookahead: None,
            ctxt,
            offset,
        }
    }

    pub fn span(&self) -> Span {
        self.span_data().compress()
    }

    pub fn span_data(&self) -> SpanData {
        SpanData {
            lo: self.offset + self.internal.span().start,
            hi: self.offset + self.internal.span().end,
            ctxt: self.ctxt,
        }
    }

    pub fn extend_span_to_current_end(&self, span: Span) -> Span {
        span.data().extend(self.span_data()).compress()
    }

    pub fn lookahead(&mut self) -> Option<<Self as Iterator>::Item> {
        if let Some(res) = self.lookahead {
            Some(res)
        } else {
            let res = self.next();
            self.lookahead = res;
            res
        }
    }

    pub fn consume_lookahead(&mut self) {
        self.lookahead = None
    }

    pub fn expect(&mut self, expected: Token) -> super::error::Result<Span> {
        match self.next() {
            Some((token, span)) if token == expected => Ok(span),
            Some((_, source)) => Err(MissingToken(expected, source)),
            None => Err(MissingTokenAtEnd(expected, self.span())),
        }
    }

    pub fn expect_simple_ident(&mut self) -> super::error::Result<Ident> {
        match self.next() {
            Some((Token::SimpleIdentifier(_), span)) => {
                let name = self.slice(&span.data());
                Ok(Ident::from_str_and_span(name, span))
            }
            Some((_, source)) => Err(MissingToken(
                SimpleIdentifier(FollowedByBracket(false)),
                source,
            )),
            None => Err(MissingTokenAtEnd(
                SimpleIdentifier(FollowedByBracket(false)),
                self.span(),
            )),
        }
    }

    pub fn expect_optional_at(
        &mut self,
        expected: Token,
        expected_at: Span,
    ) -> super::error::Result<Span> {
        match self.lookahead() {
            Some((token, span)) if token == expected => {
                self.consume_lookahead();
                Ok(span)
            }
            Some((_, span)) => Err(MissingOrUnexpectedToken {
                expected,
                expected_at,
                span,
            }),
            None => Err(MissingTokenAtEnd(expected, expected_at.extend(self.span()))),
        }
    }

    pub fn slice(&self, span: &SpanData) -> &str {
        debug_assert_eq!(self.ctxt, span.ctxt);
        &self.internal.source()
            [span.lo.index() - self.offset.index()..span.hi.index() - self.offset.index()]
    }

    pub fn byte_at(&self, pos: BytePos) -> u8 {
        self.internal.source().as_bytes()[pos.index()]
    }
}

impl<'lt> Iterator for Lexer<'lt> {
    type Item = (Token, Span);

    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        if let Some(lookahead) = self.lookahead.take() {
            Some(lookahead)
        } else {
            let res = self.internal.next()?;
            Some((res, self.span()))
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;
    struct TestLexer<'lt> {
        internal: logos::Lexer<'lt, Token>,
    }
    impl<'lt> TestLexer<'lt> {
        pub fn new(source: &'lt str) -> Self {
            Self {
                internal: Token::lexer(source),
            }
        }

        pub fn next(&mut self) -> Option<Token> {
            loop {
                match self.internal.next() {
                    Some(Token::Newline) => (),
                    res => return res,
                }
            }
        }

        pub fn slice(&self) -> &str {
            self.internal.slice()
        }
    }

    #[test]
    pub fn macro_if() {
        let mut lexer = TestLexer::new("`ifdef");
        assert_eq!(lexer.next(), Some(Token::MacroIf));
    }
    #[test]
    pub fn macro_ifn() {
        let mut lexer = TestLexer::new("`ifndef");
        assert_eq!(lexer.next(), Some(Token::MacroIfn));
    }
    #[test]
    pub fn macro_else() {
        let mut lexer = TestLexer::new("`else");
        assert_eq!(lexer.next(), Some(Token::MacroElse));
    }
    #[test]
    pub fn macro_elsif() {
        let mut lexer = TestLexer::new("`elsif");
        assert_eq!(lexer.next(), Some(Token::MacroElsif));
    }
    #[test]
    pub fn macro_definition() {
        let mut lexer = TestLexer::new("`define x(y) \\\n test");
        assert_eq!(lexer.next(), Some(Token::MacroDef));
        assert_eq!(
            lexer.next(),
            Some(Token::SimpleIdentifier(FollowedByBracket(true)))
        );
        assert_eq!(lexer.next(), Some(Token::ParenOpen));
        assert_eq!(
            lexer.next(),
            Some(Token::SimpleIdentifier(FollowedByBracket(false)))
        );
        assert_eq!(lexer.next(), Some(Token::ParenClose));
        assert_eq!(lexer.next(), Some(Token::MacroDefNewLine));
        assert_eq!(
            lexer.next(),
            Some(Token::SimpleIdentifier(FollowedByBracket(false)))
        );
    }
    #[test]
    pub fn include() {
        assert_eq!(TestLexer::new("`include").next(), Some(Token::Include));
    }
    #[test]
    pub fn simple_ident() {
        let mut lexer = TestLexer::new("test _test  egta  test$\ntest2_$ iftest");
        assert_eq!(
            lexer.next(),
            Some(Token::SimpleIdentifier(FollowedByBracket(false)))
        );
        assert_eq!(lexer.slice(), "test");
        assert_eq!(
            lexer.next(),
            Some(Token::SimpleIdentifier(FollowedByBracket(false)))
        );
        assert_eq!(lexer.slice(), "_test");
        assert_eq!(
            lexer.next(),
            Some(Token::SimpleIdentifier(FollowedByBracket(false)))
        );
        assert_eq!(lexer.slice(), "egta");
        assert_eq!(
            lexer.next(),
            Some(Token::SimpleIdentifier(FollowedByBracket(false)))
        );
        assert_eq!(lexer.slice(), "test$");
        assert_eq!(
            lexer.next(),
            Some(Token::SimpleIdentifier(FollowedByBracket(false)))
        );
        assert_eq!(lexer.slice(), "test2_$");
        assert_eq!(
            lexer.next(),
            Some(Token::SimpleIdentifier(FollowedByBracket(false)))
        );
        assert_eq!(lexer.slice(), "iftest");
    }
    #[test]
    pub fn escaped_ident() {
        let mut lexer = TestLexer::new("\\lel\\\\lel \\if ");
        assert_eq!(lexer.next(), Some(Token::EscapedIdentifier));
        assert_eq!(&lexer.slice()[1..9], "lel\\\\lel");
        assert_eq!(lexer.next(), Some(Token::EscapedIdentifier));
        assert_eq!(&lexer.slice()[1..3], "if");
    }
    #[test]
    pub fn comment() {
        let mut lexer = TestLexer::new("//jdfjdfjw4$%\r%&/**#.,|\ntest");
        assert_eq!(
            lexer.next(),
            Some(Token::SimpleIdentifier(FollowedByBracket(false)))
        );
        assert_eq!(lexer.slice(), "test")
    }
    #[test]
    pub fn block_comment() {
        let mut lexer = TestLexer::new("/*A*\n\t\n*漢字****/`test");

        assert_eq!(
            lexer.next(),
            Some(Token::MacroCall(FollowedByBracket(false)))
        );
        assert_eq!(lexer.slice(), "`test")
    }
    #[test]
    pub fn string() {
        let mut lexer = TestLexer::new(r#""lel\"dsd%§.,-032391\t    ""#);
        assert_eq!(lexer.next(), Some(Token::LiteralString));
    }
    #[test]
    pub fn unsigned_number() {
        let mut lexer = TestLexer::new("1_2345_5678_9");
        assert_eq!(lexer.next(), Some(Token::LiteralInteger));
    }
    #[test]
    pub fn macro_ref() {
        let test = "`egta";

        let mut lexer = TestLexer::new(test);
        assert_eq!(
            lexer.next(),
            Some(Token::MacroCall(FollowedByBracket(false)))
        )
    }

    #[test]
    pub fn syscall() {
        let test = "$temperature";

        let mut lexer = TestLexer::new(test);
        assert_eq!(lexer.next(), Some(Token::SystemCall))
    }
    #[test]
    pub fn real_number() {
        let mut lexer = TestLexer::new(
            "1.2
            0.1
            2394.26331
            1.2E12 // the exponent symbol can be e or E
            1.30e-2
            0.1e-0
            236.123_763_e-12 // underscores are ignored
            1.3u
            23E10
            29E-2
            7k
            30n",
        );
        assert_eq!(lexer.next(), Some(Token::LiteralRealNumber));
        assert_eq!(lexer.next(), Some(Token::LiteralRealNumber));
        assert_eq!(lexer.next(), Some(Token::LiteralRealNumber));
        assert_eq!(lexer.next(), Some(Token::LiteralRealNumber));
        assert_eq!(lexer.next(), Some(Token::LiteralRealNumber));
        assert_eq!(lexer.next(), Some(Token::LiteralRealNumber));
        assert_eq!(lexer.next(), Some(Token::LiteralRealNumber));
        assert_eq!(lexer.next(), Some(Token::LiteralRealNumberWithScaleChar));
        assert_eq!(lexer.next(), Some(Token::LiteralRealNumber));
        assert_eq!(lexer.next(), Some(Token::LiteralRealNumber));
        assert_eq!(lexer.next(), Some(Token::LiteralRealNumberWithScaleChar));
        assert_eq!(lexer.next(), Some(Token::LiteralRealNumberWithScaleChar));
    }
}
// The following is used for error messages

impl Display for Token {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        match self {
            Self::MacroDefNewLine => f.write_str("\\ (newline)"),
            Self::Newline => f.write_str("(newline)"),
            Self::Unexpected => f.write_str("unexpected Sequence"),
            Self::Include => f.write_str("`include"),
            Self::MacroIf => f.write_str("`if"),
            Self::MacroIfn => f.write_str("`ifn"),
            Self::MacroElsif => f.write_str("`elsif"),
            Self::MacroElse => f.write_str("`else"),
            Self::MacroEndIf => f.write_str("`end"),
            Self::Case => f.write_str("$case"),
            Self::EndCase => f.write_str("$endcase"),
            Self::MacroDef => f.write_str("`define"),
            Self::MacroCall(_) => f.write_str("macro call (`name)"),
            Self::SimpleIdentifier(_) => f.write_str("simple identifier"),
            Self::EscapedIdentifier => f.write_str("escaped identifier"),
            Self::LiteralString => f.write_str("string literal"),
            Self::LiteralInteger => f.write_str("unsigned number"),
            Self::LiteralRealNumber | Self::LiteralRealNumberWithScaleChar => {
                f.write_str("real number")
            }
            Self::Accessor => f.write_str("."),
            Self::Semicolon => f.write_str(";"),
            Self::Colon => f.write_str(":"),
            Self::Comma => f.write_str(","),
            Self::ParenOpen => f.write_str("("),
            Self::ParenClose => f.write_str(")"),
            Self::AttributeStart => f.write_str("(*"),
            Self::AttributeEnd => f.write_str("*)"),
            Self::SquareBracketOpen => f.write_str("["),
            Self::SquareBracketClose => f.write_str("]"),
            Self::Contribute => f.write_str("<+"),
            Self::Assign => f.write_str("="),
            Self::Hash => f.write_str("#"),
            Self::OpMul => f.write_str("*"),
            Self::OpDiv => f.write_str("/"),
            Self::OpModulus => f.write_str("%"),
            Self::Plus => f.write_str("+"),
            Self::Minus => f.write_str("-"),
            Self::OpExp => f.write_str("**"),
            Self::OpLogicNot => f.write_str("!"),
            Self::OpBitNot => f.write_str("~"),
            Self::OpArithmeticShiftLeft => f.write_str("<<"),
            Self::OpArithmeticShiftRight => f.write_str(">>"),
            Self::OpLess => f.write_str("<"),
            Self::OpLessEqual => f.write_str("<="),
            Self::OpGreater => f.write_str(">"),
            Self::OpGreaterEqual => f.write_str(">="),
            Self::OpEqual => f.write_str("=="),
            Self::OpNotEqual => f.write_str("!="),
            Self::OpLogicAnd => f.write_str("&&"),
            Self::OpLogicalOr => f.write_str("||"),
            Self::OpBitAnd => f.write_str("&"),
            Self::OpBitXor => f.write_str("^"),
            Self::OpBitNXor => f.write_str("^~/~^"),
            Self::OpBitOr => f.write_str("|"),
            Self::OpCondition => f.write_str("?"),
            Self::If => f.write_str("if"),
            Self::Else => f.write_str("else"),
            Self::While => f.write_str("while"),
            Self::For => f.write_str("for"),
            Self::Begin => f.write_str("begin"),
            Self::End => f.write_str("end"),
            Self::Module => f.write_str("module"),
            Self::EndModule => f.write_str("endmodule"),
            Self::Discipline => f.write_str("discipline"),
            Self::EndDiscipline => f.write_str("enddiscipline"),
            Self::Nature => f.write_str("nature"),
            Self::EndNature => f.write_str("endnature"),
            Self::Branch => f.write_str("branch"),
            Self::Parameter => f.write_str("parameter"),
            Self::DefineParameter => f.write_str("defparam"),
            Self::LocalParameter => f.write_str("localparam"),
            Self::Analog => f.write_str("analog"),
            Self::AnalogInitial => f.write_str("inital"),
            Self::Input => f.write_str("input"),
            Self::Inout => f.write_str("inout"),
            Self::Output => f.write_str("output"),
            Self::Signed => f.write_str("signed"),
            Self::Vectored => f.write_str("vectored"),
            Self::Scalared => f.write_str("scalared"),
            Self::String => f.write_str("string"),
            Self::Time => f.write_str("time"),
            Self::Realtime => f.write_str("realtime"),
            Self::Integer => f.write_str("integer"),
            Self::Real => f.write_str("real"),
            Self::Potential => f.write_str("potential"),
            Self::Flow => f.write_str("flow"),
            Self::Domain => f.write_str("domain"),
            Self::Discrete => f.write_str("discrete"),
            Self::Continuous => f.write_str("continuous"),
            Self::From => f.write_str("from"),
            Self::Exclude => f.write_str("exclude"),
            Self::Infinity => f.write_str("inf"),
            Self::MinusInfinity => f.write_str("-inf"),
            Self::Function => f.write_str("function"),
            Self::EndFunction => f.write_str("endfunction"),
            Self::Default => f.write_str("default"),
            Self::ConcatStart => f.write_str("{"),
            Self::ConcatEnd => f.write_str("}"),
            Self::ArrStart => f.write_str("'"),
            Self::EventStart => f.write_str("@"),
            Self::SystemCall => f.write_str("system_function_call"),
            Self::NetType => f.write_str("net_type"),
        }
    }
}
